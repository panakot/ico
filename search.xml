<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HCIA-Cloud-07-云计算发展趋势</title>
      <link href="/2020/06/16/hcia-cloud-07-yun-ji-suan-fa-zhan-qu-shi/"/>
      <url>/2020/06/16/hcia-cloud-07-yun-ji-suan-fa-zhan-qu-shi/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HCIA-Cloud-06-FusionCompute介绍</title>
      <link href="/2020/06/16/hcia-cloud-06-fusioncompute-jie-shao/"/>
      <url>/2020/06/16/hcia-cloud-06-fusioncompute-jie-shao/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HCIA-Cloud-05-虚拟化特性介绍</title>
      <link href="/2020/06/16/hcia-cloud-05-xu-ni-hua-te-xing-jie-shao/"/>
      <url>/2020/06/16/hcia-cloud-05-xu-ni-hua-te-xing-jie-shao/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HCIA-Cloud-04-云计算中的存储基础知识</title>
      <link href="/2020/06/16/hcia-cloud-04-yun-ji-suan-zhong-de-cun-chu-ji-chu-zhi-shi/"/>
      <url>/2020/06/16/hcia-cloud-04-yun-ji-suan-zhong-de-cun-chu-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HCIA-Cloud-03-云计算中的网络基础知识</title>
      <link href="/2020/06/16/hcia-cloud-03-yun-ji-suan-zhong-de-wang-luo-ji-chu-zhi-shi/"/>
      <url>/2020/06/16/hcia-cloud-03-yun-ji-suan-zhong-de-wang-luo-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HCIA-Cloud-02-计算虚拟化简介</title>
      <link href="/2020/06/15/hcia-cloud-02-ji-suan-xu-ni-hua-jian-jie/"/>
      <url>/2020/06/15/hcia-cloud-02-ji-suan-xu-ni-hua-jian-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="HCIA-Cloud-02-计算虚拟化简介"><a href="#HCIA-Cloud-02-计算虚拟化简介" class="headerlink" title="HCIA-Cloud-02-计算虚拟化简介"></a><center>HCIA-Cloud-02-计算虚拟化简介</center></h3><h4 id="1-为什么需要虚拟化？"><a href="#1-为什么需要虚拟化？" class="headerlink" title="1.为什么需要虚拟化？"></a>1.为什么需要虚拟化？</h4><p>  ⑴硬件资源没有充分利用，利用率不高，浪费硬件资源；  </p><p>  ⑵应用之间存在冲突，导致应用存在中断，无法提供服务；  </p><h4 id="2-什么是虚拟化？"><a href="#2-什么是虚拟化？" class="headerlink" title="2.什么是虚拟化？"></a>2.什么是虚拟化？</h4><p>  虚拟化是指通过虚拟化技术将一台计算机虚拟成多台逻辑计算机，在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间运行而互不影响，从而显著提高计算机的工作效率。  </p><blockquote><p>注：一台虚拟机的CPU、内存资源只能来自于同一个物理服务器。  </p></blockquote><h4 id="3-计算虚拟化的发展史"><a href="#3-计算虚拟化的发展史" class="headerlink" title="3.计算虚拟化的发展史"></a>3.计算虚拟化的发展史</h4><p><img src="001.png" alt=""></p><h4 id="4-虚拟化带来的好处"><a href="#4-虚拟化带来的好处" class="headerlink" title="4.虚拟化带来的好处"></a>4.虚拟化带来的好处</h4><p>  1）提高硬件利用率；<br>  2）降低能耗，绿色节能；<br>  3）提高IT运维效率，系统管理人员减少；<br>  4）操作系统和硬件的解耦。  </p><h4 id="5-计算虚拟化中的重要概念"><a href="#5-计算虚拟化中的重要概念" class="headerlink" title="5.计算虚拟化中的重要概念"></a>5.计算虚拟化中的重要概念</h4><p><img src="002.png" alt=""></p><p>  <strong>Guest OS</strong>：虚拟机操作系统，由物理硬件通过虚拟化手段虚拟出来虚拟机安装好的操作系统(Windows、Linux、Unix)；  </p><p>  <strong>Guest Machine</strong>：虚拟机，由物理硬件通过虚拟化软件虚拟出来；  </p><p>  <strong>Hypervisor</strong>：Hypervisor，又称虚拟机监视器（英语：virtual machine monitor，缩写为 VMM），是用来建立与执行虚拟机器的软件、固件或硬件。  </p><p>  <strong>Host OS</strong>：运行在物理主机上的操作系统。  </p><p>  <strong>Host Machine</strong>：物理主机。  </p><h4 id="6-Hypervisor的功能"><a href="#6-Hypervisor的功能" class="headerlink" title="6.Hypervisor的功能"></a>6.Hypervisor的功能</h4><p>  ① 虚拟硬件资源；  </p><p>   VMM利用底层硬件资源来构建一个包含虚拟CPU、内存和外设等的虚拟环境。在这个环境中，Guest OS认为自己运行在一台真是的计算机上，并唯一拥有这台“虚拟”机器上的所有资源。</p><p>  ② 实现对虚拟资源的调度；  </p><p>   VMM可以同时构建多个虚拟机环境，从而允许多个Guest OS并发执行，VMM利用一套策略来有效的调度资源。</p><p>  ③ 提供虚拟化环境的管理接口；  </p><p>   VMM提供一组完备的管理接口，来支持虚拟环境的创建、删除、暂停和迁移等功能。上层的管理程序通过调用VMM提供的管理接口，为用户提供管理界面。</p><h4 id="7-虚拟化的分类"><a href="#7-虚拟化的分类" class="headerlink" title="7.虚拟化的分类"></a>7.虚拟化的分类</h4><p><img src="003.png" alt=""></p><p>  ⑴裸金属虚拟化（I型虚拟化）：Hypervisor直接安装在物理机上，多个虚拟机在Hypervisor上运行。Hypervisor的实现方式就是一个特殊定制的Linux系统。比如XEN。  </p><p>  ⑵宿主虚拟化（II型虚拟化）：物理机上首先安装常规的操作系统。比如Redhat、Ubantu和Windows，Hypervisor作为OS上的一个程序模块运行，并对虚拟机进行管理。比如KVM。  </p><h4 id="8-虚拟化的特点"><a href="#8-虚拟化的特点" class="headerlink" title="8.虚拟化的特点"></a>8.虚拟化的特点</h4><p><img src="004.png" alt=""></p><p>  1）分区：在一个物理服务器上同时运行多个虚拟机；  </p><p>  2）隔离：虚拟机之间互不影响、互不干涉；  </p><p>  3）封装：虚拟机实际上是以文件形式存放，可以通过迁移或拷贝文件的方式，实现对虚拟机的迁移；  </p><p>  4）相对于硬件独立，不需要更改配置，虚拟机可以在任意服务器上运行；  </p><h4 id="9-CPU虚拟化"><a href="#9-CPU虚拟化" class="headerlink" title="9.CPU虚拟化"></a>9.CPU虚拟化</h4><p><img src="0050.png" alt=""><br><img src="005.png" alt=""></p><p>   Intel的CPU将特权级别分为4个级别：Ring0,RIing1,Ring2,Ring3。Windows只使用其中的两个级别Ring0和Ring3，Ring0只给操作系统用，Ring3谁都能用。如果普通应用程序企图执行Ring0指令，则Windows会显示“非法指令”错误信息。</p><p>  Ring 0：用于操作系统内核，优先级最高，拥有最高的“特权”； </p><p>  Ring 1和Ring 2：用于操作系统服务，优先级次之；  </p><p>  Ring 3：用于应用程序，优先级最低。  </p><h4 id="10-内存虚拟化"><a href="#10-内存虚拟化" class="headerlink" title="10.内存虚拟化"></a>10.内存虚拟化</h4><p><img src="006.png" alt=""></p><p>  我们知道，早期的计算机内存，只有物理内存，而且空间是极其有限的，每个应用或进程在使用内存时都得小心翼翼，不能覆盖别的进程的内存区。  </p><p>  为了避免这些问题，就提出了虚拟内存的概念，其抽象了物理内存，相当于对物理内存进行了虚拟化，保证每个进程都被赋予一块连续的，超大的（根据系统结构来定，32 位系统寻址空间为 2<sup>32</sup>，64 位系统为 2<sup>64</sup>）虚拟内存空间，进程可以毫无顾忌地使用内存，不用担心申请内存会和别的进程冲突，因为底层有机制帮忙处理这种冲突，能够将虚拟地址根据一个页表映射成相应的物理地址。这种机制正是虚拟化软件做的事，也就是 MMU 内存管理单元。  </p><p><img src="007.png" alt=""></p><p>  这里要说的不是这种虚拟内存，而是基于虚拟机的内存虚拟化，它们本质上是一样的，通过对虚拟内存的理解，再去理解内存虚拟化就比较容易了。  </p><p>  虚拟机本质上是 Host 机上的一个进程，按理说应该可以使用 Host 机的虚拟地址空间，但由于在虚拟化模式下，虚拟机处于非 Root 模式，无法直接访问 Root 模式下的 Host 机上的内存。</p><p>  这个时候就需要 VMM 的介入，VMM 需要 intercept （截获）虚拟机的内存访问指令，然后 virtualize（模拟）Host 上的内存，相当于 VMM 在虚拟机的虚拟地址空间和 Host 机的虚拟地址空间中间增加了一层，即虚拟机的物理地址空间，也可以看作是 Qemu 的虚拟地址空间（稍微有点绕，但记住一点，虚拟机是由 Qemu 模拟生成的就比较清楚了）。</p><p>  所以，内存软件虚拟化的目标就是要将虚拟机的虚拟地址（Guest Virtual Address, GVA）转化为 Host 的物理地址（Host Physical Address, HPA），中间要经过虚拟机的物理地址（Guest Physical Address, GPA）和 Host 虚拟地址（Host Virtual Address）的转化，即：  </p><blockquote><p>GVA -&gt; GPA -&gt; HVA -&gt; HPA  </p></blockquote><p>  其中前两步由虚拟机的系统页表完成，中间两步由 VMM 定义的映射表（由数据结构 kvm_memory_slot 记录）完成，它可以将连续的虚拟机物理地址映射成非连续的 Host 机虚拟地址，后面两步则由 Host 机的系统页表完成。如下图所示。</p><p><img src="008.png" alt=""></p><h4 id="11-I-O虚拟化"><a href="#11-I-O虚拟化" class="headerlink" title="11.I/O虚拟化"></a>11.I/O虚拟化</h4><p>  现实中的外设资源是有限的，为了满足多个客户机操作系统的需求，VMM必须通过I/O虚拟化的方式来复用有限的外设资源；VMM截获客户操作系统对设备的访问请求，然后通过软件的方式来模拟真实设备的效果。  </p><p>  <strong>I/O虚拟化可以分为：</strong></p><p>  <strong>模拟（完全虚拟）</strong>：完全使用软件来模拟真实硬件，模拟通常硬件，例如键盘鼠标，通过焦点捕获，焦点被哪个主机捕获就被哪个主机使用，性能很差；  </p><p>  <strong>半虚拟化</strong>：对硬件驱动由前端（IO frontend）直接转到后端（IO backend）调用，通常金适用于硬盘和网卡，性能高；  </p><p>  <strong>IO-through</strong>：IO透传，直接分配给虚拟机物理设备，例如直接分配一个硬盘或网卡给虚拟机，需要硬件具备IO透传技术，在Xen下由Dom0分配，但是访问使用直接使用，不经过Dom0，需要硬件支持。  </p><h4 id="12-云计算和虚拟化的区别"><a href="#12-云计算和虚拟化的区别" class="headerlink" title="12.云计算和虚拟化的区别"></a>12.云计算和虚拟化的区别</h4><p>  ⑴云计算是一种模式，虚拟化是一种技术;  </p><p>  ⑵虚拟化是云计算在IaaS层所使用技术，但并非云计算的核心关注点；  </p><h4 id="13-主流的计算虚拟化技术"><a href="#13-主流的计算虚拟化技术" class="headerlink" title="13.主流的计算虚拟化技术"></a>13.主流的计算虚拟化技术</h4><p><img src="009.png" alt=""><br><img src="0090.png" alt=""></p><p>  <strong>Xen Hypervisor</strong>：直接运行于硬件之上，是Xen客户操作系统与硬件资源之间的访问接口。通过将客户操作系统与硬件进行分类，Xen管理系统可以允许客户操作系统安全，独立的运行在相同硬件环境之上。  </p><p>  <strong>Domain 0</strong>：运行在Xen管理程序之上，具有直接访问硬件和管理其他客户操作系统的特权的客户操作系统。   </p><p>  <strong>Domain U</strong>：运行在Xen管理程序之上的普通客户操作系统或业务操作系统，不能直接访问硬件资源（如：内存，硬盘等），但可以独立并行的存在多个。  </p><h4 id="14-KVM是什么？"><a href="#14-KVM是什么？" class="headerlink" title="14.KVM是什么？"></a>14.KVM是什么？</h4><p><img src="010.png" alt=""></p><p>  KVM(Kernel Virtual Machine，内核虚拟机)基于虚拟化扩展（Intel VT或AMD-V）的x86硬件平台实现Linux的全虚拟化解决方案。  </p><p>  KVM 中，虚拟机被实现为常规的 Linux 进程，由标准 Linux 调度程序进行调度；虚机的每个虚拟 CPU 被实现为一个常规的 Linux 进程。这使得 KMV 能够使用 Linux 内核的已有功能。但是，KVM 本身不执行任何硬件模拟，需要客户空间程序通过 /dev/kvm 接口设置一个客户机虚拟服务器的地址空间，向它提供模拟的 I/O，并将它的视频显示映射回宿主的显示屏。目前这个应用程序是QEMU。  </p><h4 id="15-KVM体系架构"><a href="#15-KVM体系架构" class="headerlink" title="15.KVM体系架构"></a>15.KVM体系架构</h4><p><img src="011.png" alt=""></p><p>  <strong>libvirt</strong>：主要是用于管理KVM和Hypervisor<br>  <strong>virt-manager</strong>：是kvm图形化管理工具<br>  <strong>virt-install</strong>：是kvm的CLI命令，主要是用于创建虚拟机<br>  <strong>virt-viewer</strong>：显示虚拟机的图形控制台的最小工具  </p><h4 id="16-KVM——Libvirt管理工具"><a href="#16-KVM——Libvirt管理工具" class="headerlink" title="16.KVM——Libvirt管理工具"></a>16.KVM——Libvirt管理工具</h4><p><img src="012.png" alt=""></p><p>  Libvirt：是 KVM 的管理工具。Libvirt 除了能管理 KVM 这种 Hypervisor，还能管理 Xen，VirtualBox 等。OpenStack 底层也使用 Libvirt。</p><p>  Libvirt 包含 3 个东西：后台 daemon 程序 libvirtd、API 库和命令行工具 virsh</p><p>   （1）libvirtd是服务程序，接收和处理 API 请求；</p><p>   （2）API 库使得其他人可以开发基于 Libvirt 的高级工具，比如 virt-manager，这是个图形化的 KVM 管理工具，后面我们也会介绍；</p><p>   （3）virsh 是我们经常要用的 KVM 命令行工具，后面会有使用的示例。作为 KVM 和 OpenStack 的实施人员，virsh 和 virt-manager 是一定要会用的。</p><h4 id="17-KVM默认操作I-O流程"><a href="#17-KVM默认操作I-O流程" class="headerlink" title="17.KVM默认操作I/O流程"></a>17.KVM默认操作I/O流程</h4><p><img src="013.png" alt=""></p><p>  1） 虚拟机中的磁盘设备发起一次IO操作请求；   </p><p>  2) KVM模块中的I/O Trap Code（I/O捕获程序）将这个IO操作请求捕获到，进行相应的处理，然后将处理后的请求放到I/O共享页中；  </p><p>  3) KVM模块会通知QEMU，告诉它有新的I/O操作请求放到了共享页中；   </p><p>  4) QEMU收到通知后，到共享页中获取该I/O操作请求的具体信息；   </p><p>  5) QEMU对该请求进行模拟，同时根据I/O操作请求的信息调用运行在内核态的设备驱动，去进行真正的IO操作；   </p><p>  6) 通过设备驱动去对物理硬件执行真正的IO操作；   </p><p>  7 QEMU将执行后的结果返回到共享页中，同时通知KVM模块已完成了此次的I/O操作；   </p><p>  8) I/O捕获程序从共享页中将返回的结果读取出来；  </p><p>  9) I/O捕获程序将操作结果返回给虚拟机； </p><p>  10) 虚拟机的将结果返回给发起操作的应用程序。   </p><h4 id="18-KVM——Virtio的I-O操作流程"><a href="#18-KVM——Virtio的I-O操作流程" class="headerlink" title="18.KVM——Virtio的I/O操作流程"></a>18.KVM——Virtio的I/O操作流程</h4><p><img src="014.png" alt=""></p><p>  1) 第一步也是由虚拟机发起I/O操作请求；   </p><p>  2) 第二步的时候和使用默认模型不一样，这个I/O操作请求不会经过I/O捕获程序，而是直接以前后端的形式放到环形缓冲区，同时KVM模块通知后端驱动；   </p><p>  3) QEMU到环形缓冲区获取到操作请求的具体信息； </p><p>  4) 后端驱动直接调用真实的物理设备驱动进行具体的I/O操作； </p><p>  5) 由真实的设备驱动完成此次操作；   </p><p>  6) QEMU将完成结果返回到环形缓冲区，并且由KVM模块通知前端驱动；   </p><p>  7) 前端驱动从环形缓冲区获取到此次I/O操作的结果；</p><p>  8) 前端驱动将结果返回给具体发起该操作的应用程序。</p><h4 id="19-FusionCompute是什么？"><a href="#19-FusionCompute是什么？" class="headerlink" title="19.FusionCompute是什么？"></a>19.FusionCompute是什么？</h4><p><img src="015.png" alt=""></p><p>  <strong>FusionCompute</strong>是云操作系统软件，主要负责对虚拟资源、业务资源、用户资源的集中管理。它采用统一的接口，对这些虚拟资源进行集中调度和管理，从而降低业务的运行成本，保证系统的安全性和可靠性，协助运营商和企业构筑安全、绿色、节能的云数据中心能力。</p><h4 id="20-FusionComput产品结构"><a href="#20-FusionComput产品结构" class="headerlink" title="20.FusionComput产品结构"></a>20.FusionComput产品结构</h4><h5 id="软件组成"><a href="#软件组成" class="headerlink" title="软件组成"></a><strong>软件组成</strong></h5><p><img src="016.png" alt=""></p><p>  <strong><code>FusionCompute</code></strong>由 <strong><code>CNA</code></strong>（ComputingNode Agent，计算节点代理）、<strong><code>VNA</code></strong>虚拟节点代理，部署在CNA上，实施计算、存储、网络的虚拟化的配置管理、<strong><code>VRM</code></strong> (Virtual Resource Manager，虚拟资源管理器) 组成。</p><p>  下表介绍FusionCompute各模块功能：  </p><table boder="0"> <tbody><tr>   <td align="center">模块</td>   <td align="center">功能</td> </tr>  <tr>   <td align="center">CNA</td>   <td>CNA主要提供以下功能：<ul><li><p>提供虚拟计算功能。  </p></li><li><p>管理计算节点上的虚拟机。  </p></li><li><p>管理计算节点上的计算、存储、网络资源。  </p> </li></ul></td> </tr><tr><td align="center">VRM</td><td>VRM主要提供以下功能：<li><p>管理集群内的块存储资源。<br>通过DHCP（Dynamic Host Configuration Protocol）为虚拟机分配私有IP地址。  </p></li><li><p>管理集群内的计算节点，将物理的计算资源映射成虚拟的计算资源。  </p></li><li><p>管理集群内的网络资源(IP/VLAN/DHCP)，为虚拟机分配IP地址。  </p></li><li><p>管理集群内虚拟机的生命周期以及虚拟机在计算节点上的分布和迁移。  </p></li><li><p>管理集群内资源的动态调整。  </p></li><li><p>通过对虚拟资源、用户数据的统一管理，对外提供弹性计算、存储、IP等服务。  </p></li><li><p>通过提供统一的操作维护管理接口，操作维护人员通过WebUI远程访问FusionCompute对整个系统进行操作维护，包含资源管理、资源监控、资源报表等。  </p></li></td></tr></tbody></table><p>  <strong>VRM</strong>是FusionCompute系统的管理单元，一般运行在虚拟机上，能够对系统的虚拟资源、业务资源、用户资源进行集中管理，为管理员提供统一的维护操作接口。</p><h5 id="接口与协议"><a href="#接口与协议" class="headerlink" title="接口与协议"></a>接口与协议</h5><p>  FusionCompute提供开放、标准的协议接口，可与多种设备实现对接或互通，与对接实体之间的接口与协议如下图所示。  </p><p><img src="017.png" alt=""></p><p>FusionCompute支持的接口作用:  </p><p>  也即VRM系统对外提供的接口，主要用于FusionManager从FusionCompute获取虚拟化资源配置、告警等信息；FusionCompute根据FusionManager的指令，对虚拟机进行管理。对接实体是<code>FusionManager</code>，采用协议名称<code>REST</code>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HCIA-Cloud-01-云计算简介</title>
      <link href="/2020/06/15/hcia-cloud-01-yun-ji-suan-jian-jie/"/>
      <url>/2020/06/15/hcia-cloud-01-yun-ji-suan-jian-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="HICA-Cloud-01-云计算简介"><a href="#HICA-Cloud-01-云计算简介" class="headerlink" title="HICA-Cloud-01-云计算简介"></a><center>HICA-Cloud-01-云计算简介</center></h3><h4 id="1-什么是云计算？"><a href="#1-什么是云计算？" class="headerlink" title="1.什么是云计算？"></a>1.什么是云计算？</h4><p>  目前我们所生活带来的便利大部分都是由云计算提供的服务。如腾讯大部分的软件都是由腾讯云计算提供服务、如百度提供资料存储、手机的信息备份、云音乐、云笔记……  </p><table boder="0"><tbody><tr><td>  <img src="HCIA-Cloud-01-云计算简介/001.jpg"> </td><td>  <img src="HCIA-Cloud-01-云计算简介/002.jpg"></td><td>   <img src="HCIA-Cloud-01-云计算简介/003.jpg"></td></tr><tr> <td>  <img src="HCIA-Cloud-01-云计算简介/004.jpg"> </td> <td>  <img src="HCIA-Cloud-01-云计算简介/005.jpg"> </td></tr></tbody></table>  云计算是一种模型，它可以实现随时随地、便捷地、随需应变地从可配置计算资源共享池中获取所需的资源（例如，网络、服务器、存储、应用、及服务），资源能够快速供应并释放，使管理资源的工作量和与服务提供商的交互减小到最低限度。  <h4 id="2-云计算的特点"><a href="#2-云计算的特点" class="headerlink" title="2.云计算的特点"></a>2.云计算的特点</h4><p>  ⑴ 按需自助服务；  </p><p>  ⑵无处不在的网络接入服务；  </p><p>  ⑶与位置无关的资源池；   </p><p>  ⑷快速弹性伸缩；  </p><p>  ⑸按使用量服务费；  </p><h4 id="3-互联网、计算机及云计算发展史"><a href="#3-互联网、计算机及云计算发展史" class="headerlink" title="3.互联网、计算机及云计算发展史"></a>3.互联网、计算机及云计算发展史</h4><p><img src="006.png" alt=""><br><img src="007.png" alt=""><br><img src="008.png" alt=""></p><h4 id="4-云计算的部署模式"><a href="#4-云计算的部署模式" class="headerlink" title="4.云计算的部署模式"></a>4.云计算的部署模式</h4><p>  公有云：企业利用自买或租用其他厂商的基础设施，搭建一套云平台提供服务给他人使用。（自己搭建他人使用）<br>  私有云：企业利用自买或租用其他厂商的基础设施，搭建一套云平台提供服务给自己使用。（自己搭建自己使用）<br>  行业云：企业利用自买或租用其他厂商的基础设施，搭建一套云平台提供服务给特一类人使用。<br>  混合云：由以上两种云的组成，比如私+私、私+公、公+公  </p><h4 id="5-云计算的服务模式"><a href="#5-云计算的服务模式" class="headerlink" title="5.云计算的服务模式"></a>5.云计算的服务模式</h4><p><img src="009.png" alt=""></p><p>  <strong>IaaS</strong>：基础设施及服务，把基础设施以服务的方式提供给用户使用。  </p><p>  <strong>PaaS</strong>：平台及服务，把开发平台以服务的方式提供给用户使用。比如新浪SAE。  </p><p>  <strong>SaaS</strong>：软件及服务，把软件以服务的方式提供给用户使用。  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo——怎么将本地项目上传到GitHub仓库？</title>
      <link href="/2020/05/13/hexo-zen-me-jiang-ben-di-xiang-mu-shang-chuan-dao-github-cang-ku/"/>
      <url>/2020/05/13/hexo-zen-me-jiang-ben-di-xiang-mu-shang-chuan-dao-github-cang-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo——怎么将本地项目上传到GitHub仓库？"><a href="#Hexo——怎么将本地项目上传到GitHub仓库？" class="headerlink" title="Hexo——怎么将本地项目上传到GitHub仓库？"></a><center>Hexo——怎么将本地项目上传到GitHub仓库？</center></h2><p>  <strong>准备条件</strong>  </p><p>  1）首先需要有GitHub的账号密码，没有请注册一个账号。<a href="https://github.com/" target="_blank" rel="noopener">GitHub官网</a>  </p><p>  2) 创建一个仓库，仓库名字自定义；  </p><p>  3）安装Git，下载地址<code>https://git-scm.com/downloads</code>，默认安装即可。</p><h4 id="1-GitHub创建仓库"><a href="#1-GitHub创建仓库" class="headerlink" title="1.GitHub创建仓库"></a>1.GitHub创建仓库</h4><p><img src="001.png" alt="">   </p><h4 id="2-编辑仓库信息"><a href="#2-编辑仓库信息" class="headerlink" title="2.编辑仓库信息"></a>2.编辑仓库信息</h4><p><img src="002.png" alt="">  </p><h4 id="3-记录仓库的HTTPS链接地址"><a href="#3-记录仓库的HTTPS链接地址" class="headerlink" title="3.记录仓库的HTTPS链接地址"></a>3.记录仓库的HTTPS链接地址</h4><p><img src="003.png" alt="">  </p><h4 id="4-使用Git-Bash-Here打开本地项目，我的项目是ICO，放在系统桌面"><a href="#4-使用Git-Bash-Here打开本地项目，我的项目是ICO，放在系统桌面" class="headerlink" title="4.使用Git Bash Here打开本地项目，我的项目是ICO，放在系统桌面"></a>4.使用Git Bash Here打开本地项目，我的项目是ICO，放在系统桌面</h4><p>  我这里是一个空的项目，如实际项目JAVA、Python等，该文件夹下有相应数据。我这里将放几张照片在该文件夹中。</p><p><img src="004.png" alt="">  </p><h4 id="5-输入git-init"><a href="#5-输入git-init" class="headerlink" title="5.输入git init"></a>5.输入git init</h4><p>  使用该命令，会在ICO文件夹中成成本地的git管理（会发现使用<code>git init</code>后，ICO文件夹内会多出一个.git的文件夹）  </p><p><img src="005.png" alt=""><br><img src="006.png" alt=""></p><h4 id="6-将该ICO文件夹下的项目全部上传或上传部分文件"><a href="#6-将该ICO文件夹下的项目全部上传或上传部分文件" class="headerlink" title="6.将该ICO文件夹下的项目全部上传或上传部分文件"></a>6.将该ICO文件夹下的项目全部上传或上传部分文件</h4><p>  使用<code>git add .</code>是将项目上所有的文件添加到仓库中的意思，如果想添加某个特定的文件，只需把<code>.</code>换成这个特定的文件名即可。  </p><p><img src="007.png" alt=""></p><h4 id="7-为项目添加注释"><a href="#7-为项目添加注释" class="headerlink" title="7.为项目添加注释"></a>7.为项目添加注释</h4><p>  使用<code>git commit -m "picture</code>表示对这次提交的注释，双引号里面的内容可以根据个人的需要。我这里选择picture。  </p><p><img src="008.png" alt=""></p><h4 id="8-配置Git"><a href="#8-配置Git" class="headerlink" title="8.配置Git"></a>8.配置Git</h4><p>  如果你只是安装好了 Git 但没有配置过你的 Git ，那么现在需要做的第一件事情就是设置你的 Git 用户名和邮箱。 在 Git Bash 中执行以下两条命令配置你的用户名和邮箱，这里建议用户名和邮箱与你的 GitHub 用户名和邮箱保持一致。   </p><pre><code>$ git config --global user.name "Your_user_name"  $ git config --global user.email Your_email@example.com   </code></pre><p><img src="009.png" alt=""></p><blockquote><p><font size="4" color="FF0033">提醒</font><br>每次 Git 提交时都会附带这两条信息，用于记录是谁提交的更新，并且会随更新内容一起被记录到历史记录中。简单说，是用来标记的你的身份的</p></blockquote><p>  每次 Git 提交时都会附带这两条信息，用于记录是谁提交的更新，并且会随更新内容一起被记录到历史记录中。简单说，是用来标记的你的身份的。   </p><h4 id="9-将本地的仓库关联到GitHub上"><a href="#9-将本地的仓库关联到GitHub上" class="headerlink" title="9.将本地的仓库关联到GitHub上"></a>9.将本地的仓库关联到GitHub上</h4><p>  在<code>git remote add origin</code>后使用我们之前记录仓库的HTTPS链接地址；将本地仓库关联到GitHub上。  </p><pre><code>git remote add origin https://github.com/panakot/IOC.git</code></pre><p><img src="010.png" alt=""></p><h4 id="10-使用git-push-u-origin-master将本地项目上传到GitHub仓库上。"><a href="#10-使用git-push-u-origin-master将本地项目上传到GitHub仓库上。" class="headerlink" title="10.使用git push -u origin master将本地项目上传到GitHub仓库上。"></a>10.使用<code>git push -u origin master</code>将本地项目上传到GitHub仓库上。</h4><pre><code>git push -u origin master</code></pre><p><img src="011.png" alt=""></p><p>  输入<code>git push -u origin master</code>会弹出一个github的登录窗口，在窗口输入您GitHub的账号密码，账号密码正确后，等待项目上传到GitHub仓库中。  </p><h4 id="11-验证GitHub仓库IOC中是否有本地项目ICO的文件"><a href="#11-验证GitHub仓库IOC中是否有本地项目ICO的文件" class="headerlink" title="11.验证GitHub仓库IOC中是否有本地项目ICO的文件"></a>11.验证GitHub仓库IOC中是否有本地项目ICO的文件</h4><p><img src="012.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-部署Hexo</title>
      <link href="/2020/04/17/04-bu-shu-hexo/"/>
      <url>/2020/04/17/04-bu-shu-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="部署HEXO"><a href="#部署HEXO" class="headerlink" title="部署HEXO"></a>部署HEXO</h2><h3 id="一、-部署到GitHub"><a href="#一、-部署到GitHub" class="headerlink" title="一、 部署到GitHub"></a>一、 部署到GitHub</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h4><p>  1）如果目前有意搭建自己的个人博客，而此前没有GitHub账号，点击此处前往GitHub官网注册一个GitHub账号。账号注册流程就不在此处展示操作了，请自行注册。  </p><p>  2）注册完成后，新建一个公开仓库，仓库名称格式为<code>your_username.github.id</code>。例如我的GitHub的仓库名为<code>panakot</code>,那么生成的仓库地址名称就是panakot.github.io。  </p><p><img src="GitHub_Repository_creaate.png" alt=""></p><p>  3）创建完成后，建议用记事本记录仓库的HTTPS/SSH地址，后期设置<code>_config.yml</code>会用上。该仓库的HTTPS的一般格式为<code>https://github.com/your_username/your_reponame.github.io.git</code>;SSH的一般格式为<code>git@github.com:your_username/your_reponame.github.io.git</code>。</p><h4 id="2-安装部署插件"><a href="#2-安装部署插件" class="headerlink" title="2. 安装部署插件"></a>2. 安装部署插件</h4><pre><code>$ npm install hexo-deployer-git --save$ npm install hexo-server --save   </code></pre><h4 id="3-配置Git"><a href="#3-配置Git" class="headerlink" title="3. 配置Git"></a>3. 配置Git</h4><p>  如果你只是安装好了 Git 但没有配置过你的 Git ，那么现在需要做的第一件事情就是设置你的 Git 用户名和邮箱。 在 Git Bash 中执行以下两条命令配置你的用户名和邮箱，这里建议用户名和邮箱与你的 GitHub 用户名和邮箱保持一致。   </p><pre><code>$ git config --global user.name "Your_user_name"  $ git config --global user.email Your_email@example.com   </code></pre><blockquote><p><font size="4" color="FF0033">提醒</font><br>每次 Git 提交时都会附带这两条信息，用于记录是谁提交的更新，并且会随更新内容一起被记录到历史记录中。简单说，是用来标记的你的身份的</p></blockquote><p>  每次 Git 提交时都会附带这两条信息，用于记录是谁提交的更新，并且会随更新内容一起被记录到历史记录中。简单说，是用来标记的你的身份的。    </p><h4 id="4-配置站点-config-yml文件"><a href="#4-配置站点-config-yml文件" class="headerlink" title="4. 配置站点_config.yml文件"></a>4. 配置站点<code>_config.yml</code>文件</h4><p>  用记事本或Sublime Text3、Visual Studio Code打开，拉到文末，找到<code>deploy：</code>。这里就会用到我建议使用记事本记录仓库的SSH地址，需要修改的配置参考如下：   </p><pre><code>deploy:  type: git   # 类型填git  repo: &lt;repository url&gt; # 你的Github仓库地址  branch: master  # 分支名称。默认填写 master 如果您使用的是 GitHub ，程序会尝试自动检测。  message:  # 提交信息可以自定义，不填的则默认为提交时间   </code></pre><h4 id="5-SSH连接GitHub"><a href="#5-SSH连接GitHub" class="headerlink" title="5.SSH连接GitHub"></a>5.SSH连接GitHub</h4><p>  <strong>SSH</strong>是Secure Shell（安全外壳）的简称，是一种在不安全的网络环境中，通过加密机制和认证机制，实现安全的远程访问以及文件传输等业务的网络安全协议。SSH协议采用了典型的客户端/服务器模式，并基于TCP协议协商建立用于保护数据传输的会话通道。SSH协议有两个版本，SSH1.x和SSH2.0（本文简称SSH1和SSH2），两者互不兼容。SSH2在性能和安全性方面比SSH1有所提高。  </p><p>  使用 SSH 协议可以连接远程服务器和服务并向它们验证。 利用 SSH 密钥可以连接 GitHub，而无需在每次访问时提供用户名或密码。  </p><p>  <strong>1）检查现有SSH密钥</strong>  </p><p>  在生成 SSH 密钥之前，您可以检查是否有任何现有的 SSH 密钥。  </p><p>  <strong>Windows/Mac/Linux查询方式：</strong>  </p><p>  ① Windows打开Git Base Here,Mac/Linux打开Terminal（终端）。  </p><p>  ② 输入<code>ls -al ~/.ssh</code>以查看是否存在现有SSH密钥：  </p><pre><code>$ ls -al ~/.ssh# 列出 .ssh 目录中的文件（如果有）</code></pre><p>  ③ 检查目录列表以查看是否已经有SSH公钥。默认情况下，公钥的文件名是以下之一：  </p><pre><code>★ id_rsa.pub★ id_ecdsa.pub★ id_ed233617.pub  </code></pre><p>  如果您没有现有的公钥和私钥对，或者不希望使用任何可用于连接到GitHub的密钥对，那么请生成一个新的SSH密钥。  </p><p>  如果您看到要用于连接到GitHub的列出的现有公钥和私钥对（例如id_rsa.pub和id_rsa），则可以将SSH密钥添加到ssh-agent。  </p><p>  <strong>2）生成新SSH密钥</strong>  </p><p>  ① Windows打开Git Base Here,Mac/Linux打开Terminal（终端）。   </p><p>  ② 粘贴下面的文本（替换为您的 GitHub 电子邮件地址）。  </p><pre><code>$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"   </code></pre><p>  这将创建以所提供的电子邮件地址为标签的新 SSH 密钥。</p><pre><code>&gt; Generating public/private rsa key pair.  </code></pre><p>  ③ 提示您“Enter a file in which to save the key（输入要保存密钥的文件）”时，按 Enter 键。 这将接受默认文件位置。  </p><pre><code>&gt; Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]  </code></pre><p>  ④ 在提示时输入安全密码。 这样可以更安全的保护自己的密钥。 </p><pre><code>&gt; Enter passphrase (empty for no passphrase): [Type a passphrase]&gt; Enter same passphrase again: [Type passphrase again]   </code></pre><p><img src="ssh-keygen.png" alt=""></p><p>  <strong>3）将SSH密钥添加到GitHub账户</strong>   </p><p>  ① 找到 ~/.ssh目录下的<code>id_rsa.pub</code>，将SSH公钥钥复制到剪贴板。或通过Git Base Here使用 <code>cd ~/.ssh</code> 进入.ssh目录，然后使用 <code>ll</code> 查询当前文件夹下的文件，然后使用 <code>clip &lt; ~/.ssh/id_rsa.pub</code> 复制 ~/.ssh/id_rsa.pub文件中的公钥信息。  </p><p>  ② 登录GitHub，在页面的右上角，单击您的个人资料照片，然后单击 Settings（设置）。  </p><p>  在用户设置侧边栏中，单击 SSH and GPG keys（SSH 和 GPG 密钥）。  </p><p>  单击 New SSH key（新 SSH 密钥）或 Add SSH key（添加 SSH 密钥）。  </p><p>  在 “Title”（标题）字段中，为新密钥添加描述性标签。将密钥粘贴到 “Key”（密钥）字段。最后单击 Add SSH key（添加 SSH 密钥）。   </p><p>  如有提示，请确认您的 GitHub 密码。<br><img src="ssh_clip.png" alt=""><br><img src="GitHub_Setings.png" alt=""><br><img src="GitHub_SSH_Keys_New.png" alt=""></p><p>  <strong>4）测试SSH连接</strong>   </p><p>  以上操作完成后，测试连接时，您将需要使用密码（即您之前创建的 SSH 密钥密码）验证此操作。  </p><p>   打开Git Base Here，输入以下内容：</p><pre><code>$ ssh -T git@github.com     //对GitHub尝试ssh  </code></pre><p>  您可能会看到类似如下的警告：   </p><pre><code>&gt; The authenticity of host 'github.com (IP ADDRESS)' can't be established.  &gt; RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.  &gt; Are you sure you want to continue connecting (yes/no)?</code></pre><p>  或类似如下：  </p><pre><code>&gt; The authenticity of host 'github.com (IP ADDRESS)' can't be established.  &gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.  &gt; Are you sure you want to continue connecting (yes/no)?  </code></pre><p>  验证您看到的消息中的指纹匹配步骤 2 中的消息之一，然后输入 yes：  </p><pre><code>&gt; Hi username! You've successfully authenticated, but GitHub does not provide shell access.</code></pre><p><img src="SSH-T.png" alt="">  </p><h4 id="6-发布到GitHub"><a href="#6-发布到GitHub" class="headerlink" title="6. 发布到GitHub"></a>6. 发布到GitHub</h4><p>  在本地的 Hexo 站点根目录下，执行如下命令即可部署到 GitHub Pages 上。  </p><pre><code>$ hexo clean &amp;&amp; hexo d -g  </code></pre><blockquote><p><font size="4" color="339933">提醒</font><br>如果是第一次使用，会弹出一个登录框，需要登录你的 GitHub 账号。  </p></blockquote><h4 id="7-配置个性化域名和域名解析"><a href="#7-配置个性化域名和域名解析" class="headerlink" title="7. 配置个性化域名和域名解析"></a>7. 配置个性化域名和域名解析</h4><p>  1) 如果你拥有个人域名，请用 A 记录解析到以下 IP 中的任意一个。如果使用 CNAME 请解析到你的 GitHub 仓库名称。   </p><pre><code>185.199.108.153  185.199.109.153  185.199.110.153  185.199.111.153  </code></pre><p>   以上地址是通过域名解析你的仓库地址<code>your_username.github.io</code>得到的IP地址；用于解析您上传到GitHub网站的GitHub Pages。  </p><p><img src="nslookup_github.png" alt=""></p><p>  云服务器（阿里云、腾讯云、百度云等）设置域名解析参考如下表格。 </p><table><thead><tr><th align="center">记录类型</th><th align="center">主机记录</th><th align="center">解析路线</th><th align="center">记录值</th><th align="center">Max优先级</th><th align="center">TTL（秒）</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">@</td><td align="center">默认</td><td align="center">185.199.111.153</td><td align="center">-</td><td align="center">600</td></tr><tr><td align="center">CNAME</td><td align="center">@</td><td align="center">默认</td><td align="center">GitHub仓库地址（如我的：panakot.github.io)</td><td align="center">-</td><td align="center">600</td></tr></tbody></table><p></p><p>  2) 打开仓库，点击设置，找到GitHub Pages项目，修改Custom domain选项的值为您自定义的域名（注意此处不需要填写http/https://等前缀）。  </p><p><img src="718.png" alt=""><br><img src="719.png" alt=""><br><img src="720.png" alt="">  </p><p>  3）勾选Custom domain选项下的Enforce HTTPS选项，强制开启https。如果遇到Enforce HTTPS选项无法打开，可以稍等一会再尝试。  </p><blockquote><p><font size="4" color="339933">提醒</font><br>同时需要在本地的 source 目录新建一个 CNAME 文件，内容为你的自定义域名（不用带http | https://等前缀）。否则无法使用自定义域名功能（ hexo d 生成的文件没有 CNAME 文件，导致仓库的自定域名设置失效）。</p></blockquote><p>  如果出现以下错误提示，请参照上面的提醒操作，在本地source目录新建一个CNAME的文件，注意没有任何后缀格式，然后用记事本打开，输入您的个性化域名，如 <code>www.baihu.com</code> 或 <code>baihu.com</code> 。最后使用 <code>hexo d</code> 重新将本地的博客文件上传到GitHub Pages。  </p><p><img src="GitHub_Pages_CNAME_ERROR.png" alt=""></p><p>  <font size="4">到这里，您的网站就部署完成了，后期就可以开始写文章、修改主题、优化网站等操作了。下面的文章将如何教会您完成上面的操作。让我们继续学习吧。</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>03-配置Hexo</title>
      <link href="/2020/04/17/03-pei-zhi-hexo/"/>
      <url>/2020/04/17/03-pei-zhi-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h2><p></p>  <h3 id="建立网站"><a href="#建立网站" class="headerlink" title="建立网站"></a>建立网站</h3><p> 安装好 Hexo 后即可建立你的网站。这里整理两种方式：  </p><p>  ① 在某盘符新建一个文件夹，命名定义自己喜欢的、方便的。然后鼠标双击进入文件夹，通过鼠标右键，点击” Git Base Here “，打开当前路径。使用如下命令：  </p><pre><code>hexo init    //hexo会在当前路径的文件夹中创建所需的文件   </code></pre><p>  图1：  </p><p><img src="git_base_here1.png" alt="">  </p><p>  图2：  </p><p><img src="hexo_install.png" alt="">  </p><p>  ②随便在Windwons的任何文件夹点击鼠标右键，通过” Git Base Here “中来创建hexo所需的文件。使用命令如下：  </p><pre><code> mkdir /j/Blog/www.panakot.cn &amp;&amp; cd /j/Blog/www.panakot.cn   //在J盘的Blog文件下创建www.panakot.cn文件夹并进入到该文件夹   hexo init                                                  //hexo会在当前路径的文件夹中创建所需的文件  </code></pre><p>  图3：  </p><p><img src="hexo_mkdir.png" alt="">  </p><p> 新建完成后，指定文件夹的目录如下：</p><pre><code>.  ├── themes   ├── package.json  ├── scaffolds  ├── source  |   ├── _drafts  |   └── _posts  └──_config.yml</code></pre><p>  图4：  </p><p><img src="hexo_install_file.png" alt="">   </p><p> 重点解析该类文件夹及文件的功能和作用： </p><p>  <strong>themes</strong>   </p><p>  主题文件夹。Hexo 会根据主题来生成静态页面。默认会生成一个landscape的主题文件夹，你也可以去<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo官网</a>下载自己如意的Hexo主题，然后将下载好的主题放在该目录下，稍后再介绍如何修改主题。<br>  <strong>scaffolds</strong>  </p><p>   模版文件夹。新建文章时，Hexo会根据scaffold来建立文件。<br>   Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。  </p><p>  <strong>source</strong>   </p><p>  这个目录相当重要，当您通过<code>hexo new xxx</code>新建的文章时，所有新建的markdown文件都是在保存在这个目录下的_posts文件下。当前_posts文件夹下默认有一篇hello-world.md的markdown文件。您的文章就是在整个文件中编写的，当您通过<code>hexo g</code> 生成静态文件时，_posts文件下的.md文件，会被编译成html文件，然后放到public（目前该public文件夹不存在，因为我们还没有编译过）文件夹下。  </p><p>  _drafts用来存放草稿文件。  </p><p>  <strong>package.json</strong>   </p><p>  Hexo框架所依赖的应用程序的信息及参数。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。   </p><pre><code>package.json{      "name": "hexo-site",      "version": "0.0.0",      "private": true,      "hexo": {        "version": ""  },  "dependencies": {    "hexo": "^3.8.0",    "hexo-generator-archive": "^0.1.5",    "hexo-generator-category": "^0.1.3",    "hexo-generator-index": "^0.2.1",    "hexo-generator-tag": "^0.2.0",    "hexo-renderer-ejs": "^0.3.1",    "hexo-renderer-stylus": "^0.3.3",    "hexo-renderer-marked": "^0.3.2",    "hexo-server": "^0.3.3"  }    }</code></pre><p>  <strong>_config.yml</strong>   </p><p>   全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。</p><pre><code># Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site                //站点配置  title: Hexo           //网站标题      subtitle: ''          //网站副标题description: ''       //网站描述keywords:             //网站的关键词。使用半角逗号 , 分隔多个关键词。author: John Doe      //站长（作者）language: en          //网站使用的语言timezone: ''          //网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。# URL                 //站点连接配置## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com                  //您站点的URL（域名）root: /                                   //网站根目录permalink: :year/:month/:day/:title/      //文章的永久链接格式，默认格式:year/:month/:day/:title/ permalink_defaults:                       //永久链接中各部分的默认值pretty_urls:                              //改写 permalink 的值来美化 URL  trailing_index: true                    //是否在永久链接中保留尾部的 index.html，设置为 false 时去除;默认true  trailing_html: true                     //是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效)# Directory                           //目录设置source_dir: source                     //资源文件夹，这个文件夹用来存放内容。默认值：source。public_dir: public                     //公共文件夹，这个文件夹用于存放生成的站点文件。默认值：publictag_dir: tags                         //标签文件夹，默认值：tagsarchive_dir: archives                 //归档文件夹，默认值：archivescategory_dir: categories             //分类文件夹，默认值：categoriescode_dir: downloads/code             //Include code 文件夹，source_dir下的子目录，默认值：downloads/codei18n_dir: :lang                         //国际化（i18n），默认值：文件夹:langskip_render:                         //跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。# Writing                            //文章编写设置new_post_name: :title.md             //新文章的文件名称,默认值：default_layout: post                //预设布局，默认值：titlecase: false                    //把标题转换为 title caseexternal_link:                        //在新标签中打开链接  enable: true                      //在新标签中打开链接  field: site                          //对整个网站（site）生效或仅对文章（post）生效  exclude: ''                        //需要排除的域名。主域名和子域名如 www 需分别配置filename_case: 0                    //把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false                //显示草稿post_asset_folder: false            //启动 Asset 文件夹relative_link: false                //把链接改为与根目录的相对位址future: true                        //显示未来的文章highlight:                            //代码块的设置  enable: true                        //开启代码块高亮  line_number: true                    //显示行数      auto_detect: false                //如果未指定语言，则启用自动检测  tab_replace: ''                    //用 n 个空格替换 tabs；如果值为空，则不会替换 tabs  wrap: true                        //Wrap the code block in &lt;table&gt;  hljs: false                        //Use the hljs-* prefix for CSS classes# Home page setting                    //首页设置，可以自己决定每页显示的文章数量和显示文章的顺序# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:                    //主页设置  path: ''                            //首页根目录  per_page: 10                        //每页显示文章的数量，默认为10.  order_by: -date                    //显示文章的顺序，默认为-date,按时间逆序# Category &amp; Tag                    //标签与分类default_category: uncategorized        //默认分类，默认值uncategorizedcategory_map:                        //分类别名tag_map:                            //标签别名# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format                //时间和日期显示格式，一般没有特殊要求不需要修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD                //日期格式，默认为YYYY-MM-DDtime_format: HH:mm:ss                //时间格式，默认为HH:mm:ss## Use post's date for updated date unless set in front-matteruse_date_for_updated: false            //启用以后，如果 Front Matter 中没有指定 updated， post.updated 将会使用 date 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用# Pagination                        //分页设置## Set per_page to 0 to disable paginationper_page: 10                        //每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page                //分页目录，默认为page# Include / Exclude file(s)            //在配置文件中，设置include / exclude以使hexo显示处理或忽略某些文件/文件夹。## include:/exclude: options only apply to the 'source/' folderinclude:                            //Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。exclude:                            //设置 Hexo 忽略的文件列表ignore:                                //Ignore files/folders# Extensions                        //扩展，这里可以设置主题类型和插件## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape                      //当前主题名称。值为false时禁用主题# Deployment                        //关于网站部署的配置，常用的有部署类型和部署地址## Docs: https://hexo.io/docs/deployment.htmldeploy:                                //部署的设置  type: ''                          //网站部署的类型</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>02-安装Hexo</title>
      <link href="/2020/04/17/02-an-zhuang-hexo/"/>
      <url>/2020/04/17/02-an-zhuang-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h2><h3 id="1-安装前准备"><a href="#1-安装前准备" class="headerlink" title="1. 安装前准备"></a>1. 安装前准备</h3><p>  在安装Hexo前，首先要把承载Hexo的两个平台先安装好，分别是：  </p><blockquote><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)  </li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>  </li></ul></blockquote><p> 如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 安装 Hexo 步骤。如果没有，可以参考以下安装指导完成安装。  </p><h3 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h3><ul><li>Windows：下载并安装 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>。  </li><li>Mac：使用 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>, <a href="https://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> 或者下载<a href="https://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a>。      </li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code>。  </li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code>。    </li></ul><blockquote><p><font size="4" color="FF0033">Warning</font><br>由于墙的问题，我们访问上面的资源，有几个问题：1）加载慢； 2）打不开； 3）下载速度小。<br>这里给个建议——使用代理，不推荐使用，因为考虑安全性的问题。也可以使用这个<a href="https://mirrors.edge.kernel.org/pub/software/scm/git/" target="_blank" rel="noopener">网站</a>适用于Linux安装；Windows安装可以下载GitHub【<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">waylau/git-for-win</a>】收录了存储于百度云的下载地址,对于中国大陆地区用户，可以前往<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">淘宝 Git for Windows镜像 </a>下载Git安装包。  </p></blockquote><p></p>  <blockquote><p><font size="4" color="339933">Take a moment</font><br>如果你是 CentOS 服务器上的，可以直接使用<a href="https://github.com/PasserByJia/HexoOneClickInstallation" target="_blank" rel="noopener">HexoOneClickInstallation</a>这个脚本快速安装 Hexo。  </p></blockquote><h3 id="3-安装Node-js"><a href="#3-安装Node-js" class="headerlink" title="3. 安装Node.js"></a>3. 安装Node.js</h3><p>  Node.js 为大多数平台提供了官方的<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">安装程序</a>。对于中国大陆地区用户，可以前往<a href="https://npm.taobao.org/mirrors/node" target="_blank" rel="noopener">淘宝Node.js镜像</a>下载。  </p><p> 其它的安装方法：</p><ul><li>Windows：通过<a href="https://github.com/jasongin/nvs/" target="_blank" rel="noopener">nvs</a>（推荐）或者<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">nvm</a>安装。</li><li>Mac：使用<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>或<a href="https://www.macports.org/" target="_blank" rel="noopener">MacPorts</a>安装。</li><li>Linux（DEB/RPM-based）：从<a href="https://github.com/nodesource/distributions" target="_blank" rel="noopener">NodeSource</a>安装。</li><li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的<a href="https://nodejs.org/en/download/package-manager/" target="_blank" rel="noopener">指导</a>。</li></ul><p> 对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。<br> 安装Node.js的最佳方式  </p><p>  cURL:  </p><pre><code>$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</code></pre><p>  Wget:  </p><pre><code>$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh  </code></pre><p>  安装完成后，重启终端并执行下列命令即可安装 Node.js。  </p><pre><code>$ nvm install stable  </code></pre><h3 id="4-Hexo安装"><a href="#4-Hexo安装" class="headerlink" title="4. Hexo安装"></a>4. Hexo安装</h3><p>  所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。  </p><pre><code>$ npm install -g hexo-cli  </code></pre><h3 id="5-验证软件是否安装成功"><a href="#5-验证软件是否安装成功" class="headerlink" title="5. 验证软件是否安装成功"></a>5. 验证软件是否安装成功</h3><p>  1) 检查Git  </p><p><img src="git_v.png" alt=""></p><p>  2) 检查Node.js </p><p><img src="node_v.png" alt=""></p><p>  3) 检查Hexo </p><p><img src="hexo-v.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01-认识HEXO</title>
      <link href="/2020/04/17/01-ren-shi-hexo/"/>
      <url>/2020/04/17/01-ren-shi-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo?"></a>什么是Hexo?</h2><p> Hexo是一个快速、简洁且高效的博客框架。能够让你从小白向大师迈进，不再需要掌握很多关于前端开发的知识，不用每天撸代码，修改BUG。通过hexo，可以快速构建个人博客，并搭建到<code>GitHub</code>、<code>Coding</code>、<code>云服务器</code>、<code>码云</code>上供他人访问，实现资源共享。</p><h2 id="Hexo的特点"><a href="#Hexo的特点" class="headerlink" title="Hexo的特点"></a>Hexo的特点</h2><h3 id="1-轻量快速"><a href="#1-轻量快速" class="headerlink" title="1. 轻量快速"></a>1. 轻量快速</h3><p> Hexo的轻量快速得益于Hexo使用Node.js编写，也归功于<code>Node.js单线程</code>、<code>非阻塞I/O</code>、<code>事件机制</code>，事件环的特点。</p><p> 详细Node.js知识点，请参考<a href="https://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">Node.js教程</a> 。  </p><h3 id="2-支持Markdown"><a href="#2-支持Markdown" class="headerlink" title="2. 支持Markdown"></a>2. 支持Markdown</h3><p>  Hexo使用Markdown(或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。  </p><h3 id="3-部署方便"><a href="#3-部署方便" class="headerlink" title="3. 部署方便"></a>3. 部署方便</h3><p>  只需要通过基于Node.js和git平台，使用hexo相关命令就可以完成博客的搭建，文章的创建、生成以及部署到承载平台，如GitHub Pages、Coding Pages、Heroku、云服务器等其他承载网站平台。</p><h3 id="4-插件丰富、主题丰富"><a href="#4-插件丰富、主题丰富" class="headerlink" title="4. 插件丰富、主题丰富"></a>4. 插件丰富、主题丰富</h3><p>  Hexo有许多主题和插件供想要搭建个人博客者提供有选择性挑选自己如意的、称心的博客主题和插件。</p><h3 id="5-免费"><a href="#5-免费" class="headerlink" title="5.免费"></a>5.免费</h3><p>  Hexo的主题和插件都是免费向大众开放的。</p><h2 id="学习Hexo之前，需要准备哪些："><a href="#学习Hexo之前，需要准备哪些：" class="headerlink" title="学习Hexo之前，需要准备哪些："></a>学习Hexo之前，需要准备哪些：</h2><ul><li><del>Node.js基本知识</del></li><li><del>Git基本知识</del></li><li><del>Html语言学习</del></li><li><del>CSS</del></li><li><del>JavaScript基本知识</del></li><li>Markdown语法使用  </li></ul><p>  想要搭建属于自己的个人博客，还是需要付出一点时间、一点精力去学习有关博客搭建的知识，Markdown还是需要学习的，这关乎于你个人博客文章的排版，如果你不在意，那就不用掌握。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>H3CSE-Security(GB0-550)-第二章 Web应用防火墙[WAF]</title>
      <link href="/2020/03/24/h3cse-security-gb0-550-di-er-zhang-web-ying-yong-fang-huo-qiang-waf/"/>
      <url>/2020/03/24/h3cse-security-gb0-550-di-er-zhang-web-ying-yong-fang-huo-qiang-waf/</url>
      
        <content type="html"><![CDATA[<h3 id="第二章-Web应用防火墙（WAF"><a href="#第二章-Web应用防火墙（WAF" class="headerlink" title="第二章 Web应用防火墙（WAF)"></a><center>第二章 Web应用防火墙（WAF)</center></h3><p>  <font color="red"><strong>温馨提示：本文使用的部分图片采用的是设备型号W2000-V300-G2</strong></font>  </p><p></p><h4 id="1-Web安全概述"><a href="#1-Web安全概述" class="headerlink" title="1. Web安全概述"></a>1. Web安全概述</h4><p>  Web应用已经成为一种普适平台，广泛应用于政务、办公、购物、教学、通讯、媒体等等。  </p><p>  Web安全面临的新挑战，传统的安全防护是通过网络防火墙防80端口之外的攻击，Web攻击专攻80端口；Web安全边界模糊，因此导致网络边界、应用边界、账户权限边界模糊；Web应用系统弱点多样性，不限于CVE，因为开发Web程序的企业太多，弱点不在是固定的表征；黑客攻击门槛低，工具自动化、网上教程多这些也是导致Web安全的主要因素；网站被攻击事件频发，亡羊补牢不如事前防护。  </p><h4 id="2-WAF产品基础"><a href="#2-WAF产品基础" class="headerlink" title="2. WAF产品基础"></a>2. WAF产品基础</h4><p>  <strong>1）WAF—Web Application Firewall（Web应用防火墙）</strong>   </p><p>  WAF是针对Web应用系统采取相应安全监测及防护措施的专用硬件网关类产品，区别于传统防火墙基于五元组进行的访问控制，WAF主要是通过执行丰富和灵活的HTTP/HTTPS或其他相关协议的安全检测策略来对用户的Web应用系统进行深度特征过滤机防护。  </p><p><img src="WAF.png" alt="">    </p><p>  H3C Web应用防火墙（简称H3C WAF）是H3C自主开发、拥有知识产权的新一代的Web安全防护产品。与上一代以代理技术为基础Web应用防火墙不同点主要在于：上一代Web防火墙以研究安全攻击特征为核心，依赖于安全特征匹配技术；新一代Web应用防火墙以用户网站为核心，自动依据网站学习建模，生成基于用户网站的专有安全规则，因此防护更有针对性，误判极低，且性能得到更大的提升。H3C WAF结合多年研发经验，充分考虑Web应用系统可能存在的安全风险，通过对网络层、Web服务层、Web应用程序层、应用内容属性四个层面进行全方位安全分析与防御。</p><p>  <strong>2）功能优势</strong>  </p><p>  ① 双引擎保护  </p><p><img src="po.png" alt="">    </p><p>  ② 支持OWASP-top10安全防护  </p><p><img src="top.png" alt="">   </p><p>  <strong>3)WAF系统架构</strong>  </p><p><img src="WAF-System.png" alt=""><br>  <strong>4)H3C WAF产品特点</strong> </p><p>  ①防御能力强；<br>  ②强大的CC攻击防御能力；<br>  ③易用性好；<br>  ④安全态势实时告知；<br>  ⑤地图动态分析；<br>  ⑥IP信誉库；<br>  ⑦规则智能适应；<br>  ⑧多种防御措施；<br>  ⑨部署模式灵活；<br>  ⑩多协议支持；  </p><h4 id="3-WAF设备管理"><a href="#3-WAF设备管理" class="headerlink" title="3. WAF设备管理"></a>3. WAF设备管理</h4><p>  <strong>1）管理口</strong></p><ul><li>对于ESS6712P02之前的版本：   </li></ul><p>   ◎ 在出厂配置下，默认所有接口都属于VLAN 1的Access口，VLAN 1配置有默认IP：192.168.0.1。<br>   ◎ 对于如下型号的设备：W2000-AK410、W2000-AK420、W2020-G、W2040-G、W2080-G、W2200-G，建议使用GE0/0口作为管理口，需要使用串口登录，通过命令行修改GE0/0接口为路由口、配置IP，并配置管理网段的路由。<br>   ◎ 对于如下型号的设备：W2000-AK430、W2000-AK440、W2010-G，建议使用GE0/7口作为管理口，通过命令行修改GE0/7接口为路由口、配置IP，并配置管理网段的路由。  </p><ul><li>对于ESS6712P02之后的版本：</li></ul><p>   ◎ 在出厂配置下，设置有默认管理口，管理口为路由口，并配置有默认IP：192.168.0.1。<br>   ◎ 对于如下型号的设备：W2000-AK410、W2000-AK420、W2020-G、W2040-G、W2080-G、W2200-G，默认管理口为GE0/0接口。<br>   ◎ 对于如下型号的设备：W2000-AK430、W2000-AK440、W2010-G，默认管理口为GE0/7接口。<br>   ◎如果使用默认管理IP：192.168.0.1，则不需其他配置。如果需要修改管理IP，可以使用串口登录，通过命令行对管理口重新配置IP，并配置管理网段的路由。    </p><p>  <strong>2）设备登录</strong>  </p><p>  ★ Console登录<br>  在设备出厂状态下，或特殊情况时，可通过Console接口登录设备进行管理。默认Console登录用户名：admin ，密码：admin 。默认Console接口的波特率：9600，COM口选择相应的COM端口，其他保持默认设置即可。使用命令行配置管理口的步骤如下：<br>  ① 设置管理口为路由模式<br>    set  interface GE0/0 mode route<br>  ② 设置管理口IP<br>    set interface GE0/0 ip 183.1.0.10/24<br>  ③设置管理口的路由<br>    set route 101.1.0.0/16 gw 183.1.0.1<br>  ★ Web页面登录<br>  Web管理的具体登录步骤如下：<br>    ① 连接设备和PC，用交叉线将PC和设备的管理口相连；<br>    ② 为PC配置IP地址，保证能与设备互通修改管理PC的IP地址为192.168.0.0/24（192.168.0.0/24网段内除192.168.0.1的任意地址即可），例如192.168.0.100。<br>    ③ 启动浏览器输入登录信息，在浏览器地址栏内输入 <code>https://192.168.0.1</code> 即可进入Web网管登录页面，输入用户名：admin ，密码：admin ,点击&lt;登录&gt;按钮即可进入Web管理页面进行相关操作。  </p><p>  <strong>3）导入许可</strong>  </p><p>  H3C互联网安全实验室会不断更新Web攻击特征库，以让WAF能根据最新的数据库来检测、阻止病毒和Web攻击。但是各种特征更新都是有使用期限的，其许可证到期后，想要获取最新的特征库更新，则必须更新许可证文件以获得授权，进而继续使用并及时更新特征库。选择“系统维护 &gt; 许可证”页面，可进行许可证的导入。  </p><p><img src="license.png" alt="">  </p><p>  <strong>4)升级</strong>  </p><p>  ▲ 软件版本升级<br>  软件版本升级需要在Web页面进行升级。登录后，点击“系统维护 &gt; 系统更新 &gt; 系统固件”页面，在“更新Firmware”处导入版本升级包，点击应用即可。  </p><p><img src="system-update.png" alt="">  </p><p>  <strong><font color="red">注：由于升级版本会自动重启设备，请在升级前手动保存最新配置，以防配置丢失。更新方式可以设定“立即更新”和“定时更新”</font></strong>  </p><p>  ▲ 特征库升级——手动更新<br>  首次更新特征库，可以选择手动更新。点击“系统维护 &gt; 系统更新 &gt; 特征库”，以更新病毒特征库为例，在“更新”一栏点击“手动更新病毒特征库”，并点击应用。IPS特征库、Web攻击特征库的手动更新方法与病毒特征库类似。    </p><p><img src="ips-update.png" alt="">  </p><p>  ▲ 特征库升级——自动更新<br>  在首次手动更新完特征库后，可以设置系统按照固定的时间间隔或设置每天的某个时刻，连接“H3C更新中心”获取最新的更新信息。勾选“特征库/引擎自动更新”；选择更新间隔。选择“按小时”，可以指定更新间隔为几小时。选择“按日期”，可以指定每天下载更新的时间。如可以输入04:00，系统将在凌晨4点下载更新；点击应用。  </p><p>  <strong><font color="red">注：系统根据域名连接更新中心，因此需要管理员事先设置好能够解析公网域名的DNS服务器，如8.8.8.8等。</font></strong>  </p><h4 id="4-WAF工作原理及部署方式"><a href="#4-WAF工作原理及部署方式" class="headerlink" title="4. WAF工作原理及部署方式"></a>4. WAF工作原理及部署方式</h4><p>  WAF部署模式分为：透明模式、反向代理模式、旁路监听/阻断模式、混合模式。  </p><p>  <strong>透明模式</strong><br>  透明模式支持Bypass，故障恢复快；不改变原有网络结构，对客户端及服务器是透明的；安全防护能力强；实现即插即用；所有局点开局均推荐使用本模式。  </p><p><img src="waf1.png" alt=""><br>  透明模式时，WAF不做代理，将对去往服务器的报文检测完成之后再发送给服务器，从服务器返回的报文同样经过WAF检测再发送给客户端。   </p><p><img src="waf1-1.png" alt="">  </p><p>  <font size="2"><strong>透明模式配置</strong></font><br>  在“系统配置 &gt; 侦测模式”页面，选择透明模式；<br>  在“网络配置 &gt; 网络接口”页面，配置业务口均为透明模式，接口GE0/1、bond1均为透明模式；<br>  在“网络配置 &gt; 虚拟局域网”页面，将上下行接口加入到VLAN 116中，同房的方法将bond1 加入到116；<br>  在“安全策略 &gt; Web安全策略”页面，根据需要添加或调整Web应用防护策略，系统默认有一条名为default的策略。<br>  在“安全策略 &gt; 策略引用”页面，将添加的Web安全策略与Web服务器进行关联：添加新的引用策略，上联口选择流量入接口GE0/1，选择入侵防护策略和Web安全策略，如default。添加被保护服务器，设置服务IP、端口和域名。<br>  在“安全策略 &gt; 策略引用”页面，将添加的Web安全策略与Web服务器进行关联：启动策略，即可实现对Web服务器的安全防护功能。  </p><blockquote><p><font size="5" color="red">注：</font><br>☆ 透明部署时，如需要Bypass功能，WAF的进、出口需要选择一对Bypass口；<br>☆ 各型号设备包含的Bypass口可参照《Web应用防火墙开局指导书》中各个面板示意图的介绍；<br>☆ 如果设备自身不包含Bypass口，需要搭配插卡进行使用，各个插卡包含Bypass口可参照实际使用的插卡规格说明。 </p></blockquote><p>  <strong>反向代理模式</strong>    </p><p>  反向代理模式下，WAF旁路部署在交换机上，所有访问流量经过WAF转发到内网Web服务器上，需要将Web服务器映射到WAF的虚拟IP上，WAF能够完全隐藏Web服务器的真实IP地址，对外只提供Web服务器的虚拟IP，有效保障Web服务器安全。  </p><p><img src="waf2.png" alt="">  </p><p>  优点：可隐藏后端服务器地址和拓扑结构，防护级别高，可实现攻击阻断；缺点：会改变网络拓扑的逻辑结构，改变路由走向，出现问题时恢复时间较长。  </p><p>  反向代理模式下，WAF会对连接进行代理，客户端先和WAF建立连接，之后再和服务器建立连接。  </p><p><img src="waf2-1.png" alt=""></p><p>  <font size="2"><strong>反向代理模式配置</strong></font> </p><p>  以下图为例   </p><p><img src="waf2-2.jpg" alt=""></p><p>  当WAF部署为反向代理模式时，需要将WAF旁路接在业务PC和服务器之间的交换机上，并且需要配置交换机使业务PC网段、以及WAF的代理IP网段都可通。<br>  网络拓扑配置完成后，需要在WAF上进行的配置如下：<br>  ⑴ 在“系统配置 &gt; 侦测模式”页面，勾选反向代理模式，点击应用，并在页面右上角点击保存配置，之后需要<font color="red">重启</font>设备以使模式生效。<br>  ⑵重启完成后，点击反向代理模式的“配置”按钮，进入配置页面；<br>  ⑶首先配置反向代理的业务接口，选择G0/1接口为代理口，选择后点击应用；设置好反代接口，需要配置代理IP和服务器IP的对应关系，在接口下方的服务器设置项点击添加按钮；<br>  ⑷在反向代理配置业，设置用于代理的IP地址、子网掩码和代理端口，服务器IP地址端口为真实Web服务器地址和端口，填写完成后点击应用按钮；<br>  ⑸在WAF上完成上述配置后，可以再“网络配置 &gt; 网络接口”页面查看配置情况；可以观察到，veth1接口被配置了代理IP，工作模式为路由模式，此时代表反向代理模式配置成功。  </p><blockquote><p><font size="5" color="green">说明：</font><br>名称为veth1的接口，是WAF本身的一个虚接口，反向代理模式下，配置的代理IP都会关联到该虚接口上。<br>若配置完反向代理接口地址后，ping不通该地址，可以在“网络接口”页面点击veth1接口，查看其管理访问中的ping方式是否开启。若没有开启，勾选该方式并点击应用，之后再尝试是否能够ping通。 </p></blockquote><p>  ⑹由于系统仅有直连路由和添加的静态路由，因此需要在路由表中添加一条默认路由，使WAF上的业务流量都从反代业务口进出。<br>  ⑺最后，需要针对需要防护的服务器配置相关策略，在“安全策略 &gt; 策略引用”中添加一条项目，上联口选择veth0，入侵防护策略、Web安全策略可选择默认策略，服务器安全组中添加防护的服务器，完成后启用该条策略引用项即可。</p><blockquote><p><font size="5" color="green">说明：</font><br>由于反代模式下，配置的代理IP被关联到虚接口veth1上，而veth0和veth1是WAF本身的一对虚接口对，流量上代理时，是从veth0虚接口流入的，所以需要将veth0设为上联接口，才会对流量进行规则检测。<br>服务器安全组中添加的地址为防护服务器的真实地址。  </p></blockquote><p>  <strong>旁路监听/阻断模式</strong></p><p>  在WAF首次部署或担心部署后产生业务连续性和可用性影响时，可以选择将WAF进行侦测模式旁路部署，通过接收交换机镜像过来的镜像流量来进行流量分析，不会对真实业务流量产生任何阻止动作及性能瓶颈影响，是最快速易用的部署方式。 </p><p>  在充分考虑用户应用场景的情况下，SecPath-WAF还支持旁路阻断功能，可以通过设置专用的阻断端口实现TCPrest功能，在侦测模式下完成威胁流量的防御拦截。  </p><p><img src="waf3.jpg" alt="">  </p><p>  <font size="2"><strong>旁路监听/阻断模式配置</strong></font> </p><p>  ⑴在“网络配置 &gt; 网络接口”页面，点击作为阻断口的接口，在设置页面将该接口的模式设为路由模式。<br>  ⑵在H3C WAF的“系统配置 &gt; 侦测模式”页面选择旁路监听莫使，并勾选旁路阻断，并选择阻断接口，假设为G0/3，点击应用，并在页面右上角点击保存配置；然后重启系统。<br>  ⑶在服务器交换机上创建镜像组，将客户端相连的G1/0/6端口与WAF阻断口相连接的G1/0/9端口设置在同一VLAN中，如vlan 2，并配置网关。。将于Web-server相连的G1/0/8端口设置在另一个VLAN中，如vlan 3，并配置网关。<br>  ⑷在“安全策略 &gt; 策略引用”页面添加一条策略引用，上连接口选择镜像口G0/2,入侵防护策略、Web安全策略选择默认策略，服务器安全组添加需要防护的服务器地址（参考反代模式配置），并启用策略。<br>  ⑸添加需要防护的服务器的IP/掩码以及协议/端口，点击添加，点击应用，后面就可以进行攻击防护。  </p><p>  <strong>混合模式</strong>  </p><p>  WAF还可以在透明及混合部署下同时部署使用，使得用户在选择部署方案时更加灵活、便捷。部署方式可以综合参照透明模式和反代模式下的配置。  </p><h4 id="5-WAF功能介绍及配置"><a href="#5-WAF功能介绍及配置" class="headerlink" title="5. WAF功能介绍及配置"></a>5. WAF功能介绍及配置</h4><p>  <strong>1）监控面板</strong>  </p><p>  监控面板通过图标展示了WAF当前的安全概况，界面如图所示： </p><p><img src="jiankong.jpg" alt="">  </p><p>  <font size="2"><strong>监控面板可以显示：</strong></font> </p><ul><li>自身健康：根据设备的CPU、内存、硬盘使用率计算出当前设备的健康状态；</li><li>威胁风险：根据1小时内设所拦截的攻击数目通过加权算法计算出内部网络的风险值；</li><li>安全事件：1小时内所发现的威胁事件数量展示；</li><li>事件分类：通过饼状图显示当前一小时内病毒、入侵防御、WAF拦截事件各自所占比例几个字的详细类别；</li><li>事件告警：显示Web安全、网络入侵、病毒感染的最近日志；</li><li>事件源：显示Web安全、网络入侵、病毒检测的攻击源，用户直接点击后方的操作可将原地址直接封禁（加入黑名单）或放入例外列表中（加入白名单）；</li><li>接口状态：显示设备的前面板状态，鼠标悬停至端口会显示该接口名称及协商速率。  </li></ul><p>  <strong>2）状态监控</strong>  </p><p>  在完成WAF的设置、服务器安全检测策略的创建后，WAF将开始检查通过WAF的网络流量并在状态监控中显示各种详细的系统信息和流量检测信息。管理员可以查看下列信息：  </p><p>  ★ 系统状态：查看设备系统相关信息及接口流量信息；<br>  ★ Web安全：查看并展示针对Web服务器的各种拦截情况；<br>  ★ 入侵防护：查看并展示入侵防御引擎的工作状况；<br>  ★ 流量统计：显示统计的Web服务器的访问数及攻击数。    </p><p>  <font size="2"><strong>① 系统状态</strong></font>   </p><p>  系统状态分为系统信息及网络信息，用于显示系统当前的资源使用率及工作状态。<br>  选择“系统状态 &gt; 系统信息”，右侧页面显示当前引擎和特征库版本许可信息和历史的CPU使用的统计数据。如下图所示。  </p><p><img src="system-tab.jpg" alt="">  </p><p>  点击版本信息中的版本升级及许可状态中的更新许可，可跳转到系统更新及许可证界面进行更新导入。</p><p>  在“主机信息”下方，以图表方式显示CPU/内存使用信息。如果超长时间处于高CPU使用状态，请管理员查找具体原因。</p><p>  管理员可以在“时间间隔”处选择显示的统计数据时间间隔：可选项及含义分别为：</p><pre><code>※ 5分钟：选择后界面将直接显示当前时刻之前5分钟的统计信息。  ※ 一小时：选择后界面将直接显示当前时刻之前的一个小时内的统计信息。※ 一天：选择后界面将直接当前时刻之前24小时的统计信息。※ 一个月：选择后界面将直接当前时刻之前一个月的统计信息。</code></pre><p>  选择菜单“系统状态 &gt; 网络信息”，页面显示所有接口的详细统计信息。如下图所示。</p><p><img src="system-3.jpg" alt="">  </p><p> <font size="2"><strong>各列说明如下表：</strong></font>   </p><p> 表2-1 接口信息表   </p><p></p><table><tbody><tr> <th width="100">参数</th> <th width="100">说明</th></tr><tr> <th>接口</th> <th align="left">显示接口名称。</th></tr><tr> <th>IP 地址</th> <th align="left">显示分配给接口的IP地址。如果接口工作在交换模式，则显示为0.0.0.0。</th></tr><tr> <th>状态</th> <th align="left">显示接口网卡工作是否正常：“up”或“down”。<p>说明：</p><p>就vlan1接口来说，vlan1是伪接口，受到以透明模式配置的所有接口的限制。如果所有透明模式接口都处于断开状态，那么vlan1也将处于断开状态。如果任一个透明模式接口处于连接状态，那么vlan1也将处于连接状态。</p></th></tr><tr> <th>工作模式</th> <th align="left">显示接口工作模式：“route” “transparent” “bond”。</th></tr><tr> <th> Rx Pkts</th> <th align="left">在接口上接收到的数据包的总数。</th></tr><tr> <th>Rx Errors</th> <th align="left">在接口上接收到的错误包的总数。</th></tr><tr> <th>Tx Pkts</th> <th align="left">通过接口发送的数据包的总数。</th></tr><tr> <th>Tx Errors</th> <th align="left">通过接口发送的错误包的总数。</th></tr></tbody></table>  <p>  <font size="2"><strong>② Web安全</strong></font>   </p><p>  管理员可以在此处查看日志中记录的关于Web服务器受到的攻击防护的统计信息。选择 状态监控 &gt; Web安全，在下级菜单下管理员可以查看到详尽的统计信息，包括如下内容：</p><ul><li><p>攻击统计：显示区域时间内设备拦截的攻击数以及攻击类别和源排名等信息。</p></li><li><p>会话信息：页面显示过去单位时间内通过设备的HTTP会话并行和新建详细统计信息。</p></li><li><p>Web威胁：显示挂马、Web shell、信息泄漏等安全时间的统计。</p></li><li><p>Web缓存：管理员在此可以实时监控被保护的服务器上所有被监控的文件类型。</p></li><li><p>实时监测：显示当前实时发生的日志。 </p></li></ul><p>  <font size="2"><strong>Web安全——攻击统计</strong></font>   </p><p>  选择菜单Web安全 &gt; 攻击统计，页面显示过去一小时内设备所检测的的威胁风险。如下图所示。  </p><p><img src="web.jpg" alt="">  </p><p>  <strong>∴</strong> 界面上方显示了当前1小时的连接数及安全WAF设备拦截的针对Web服务器的攻击及病毒数量。</p><p>  <strong>∴</strong> 攻击地图通过用户手工输入本地公网IP地址定位安全网关的位置后，查询1小时内的攻击统计，在地图中标注出威胁的源地址。</p><p>  <strong>∴</strong> 下方通过填充线形图展示出一小时内发生的攻击次数，帮助管理员了解网络威胁风险发生的高峰时间。</p><p>  <strong>∴</strong> 右侧通过柱状图显示1小时内攻击类型和攻击源地址的top10。</p><p>  <font size="2"><strong>Web安全——会话信息</strong></font>   </p><p>  选择菜单 Web安全 &gt; 会话信息，页面显示过去1小时内通过设备的HTTP会话并行和新建详细统计信息。如下图所示。  </p><p><img src="web-security-session.jpg" alt="">  </p><p>  <font size="2"><strong>Web安全——Web威胁</strong></font>  </p><p>  选择菜单Web安全 &gt; Web威胁可查看对WAF保护的网站进行挂马监测、Web SHELL监测及信息泄露监测的结果。如下图所示。</p><p><img src="web-security-policy.jpg" alt="">  </p><blockquote><p><font color="red" size="4"><strong>注意：</strong></font><br>“信息泄露监测”统计的是WEB安全策略中“数据防泄漏”相应的攻击信息。</p></blockquote><p>  <font size="2"><strong>Web安全——Web缓存</strong></font></p><p>  管理员在此可以实时监控被保护的服务器上所有被监控的文件类型是否被篡改，还可以分别将设备缓存的文件、最近一个检查周期获取的服务器文件下载到管理员主机上。如果管理员可以判断被篡改文件是合法修改的，可以通过执行同步来更新缓存中的文件，使得用户能够访问最新的文件。</p><p>  (1)选择“Web安全 &gt; Web缓存”，管理员可以查看到所有缓存文件的记录。红色背景显示的记录表示缓存文件的修改时间与设备最新获取的服务器文件的修改时间不一致，提示该页面可能已被篡改。  </p><p><img src="web-cookies.jpg" alt="">  </p><p>  如果显示的信息中有乱码信息，可以尝试点击“启动编码自动转换”，如果还有乱码，可以在浏览器的菜单栏中选择“查看 &gt; 编码”，选择合适的编码信息。</p><p>  “总页数”处显示当前信息的总共页数，“页号”显示当前为第几页。管理员可以点击翻页按钮进行查看，也可以在“页号”处输入页码，点击“翻到”可以直接跳转至指定的页面。</p><p>  (2)配置Web缓存，在“缓存检查周期”处设置系统每隔多长时间对缓存进行一次检查。在“缓存文件可用磁盘空间大小”处设置系统预留给Web缓存的磁盘空间大小，单位为GB，可设置范围为1-50。</p><p>  (3)查询监控信息，管理员可以在上方“URL”处输入一个或多个查询条件，并选择“搜索”，点击“运行”按钮查询符合条件的监控信息。</p><p>  (4)和最新获取的服务器文件同步，如果管理员可以判断被篡改文件是合法修改的，则可以通过执行同步，将设备缓存中的Web页面替换为最近一个检查周期获取的服务器页面。在“URL”处输入查询条件，然后选择“同步服务器”，之后点击“运行”按钮则会用设备最近一个检查周期获取的服务器文件替换设备缓存中的文件。如果直接选择“篡改内容”并选择“同步服务器”，之后点击“运行”按钮则会用对应的服务器文件替换所有被篡改的文件。同步成功会弹出下图所示的提示框。</p><p><img src="operation.jpg" alt="">  </p><p>  (5)清除缓存信息，如果管理员删除了Web server上的某些页面，网站管理员就需要做清除缓存的操作，以便和服务器保持一致。输入查询条件，下拉菜单选择“清除缓存”，可以将WAF设备的缓存中保存的符合条件的Web页面删除。</p><p>  (6)下载缓存文件，点击某一条监控记录的“缓存文件”一栏对应的URL链接，可以将WAF设备上缓存的Web页面保存至管理员PC上。</p><p>  (7)下载服务器文件，点击“服务器文件”一栏对应的URL链接，可以将WAF设备在最近一个检查周期获取的Web服务器的文件保存至管理员PC上。</p><blockquote><p><font color="red" size="4"><strong>注意：</strong></font><br>反向代理模式下，WAF按周期检查服务器缓存文件时，会产生客户端IP为代理IP的访问日志，并且如果开启了自学习，也会学习到这些流量的信息。</p></blockquote><p>  <font size="2"><strong>Web安全——实时监控</strong></font></p><p>  选择菜单Web安全 &gt; 实时监测可查看到当前1小时内最新的25条日志，方便在发生误判或攻击时，及时定位问题。界面如下：  </p><p><img src="web-security-jk.jpg" alt="">  </p><p>  <strong>3) 安全策略</strong>  </p><p>  介绍制定Web服务器的防护策略。首选需要定义安全策略，设置需要检测的攻击类型以及具体的检测参数，然后引用策略添加需要保护的服务器组，即对一组Web服务器的安全保护策略，通过在策略中需要定义受保护的Web服务器群组，并引用适当的安全策略，从而实现对不同服务器可定制不同的保护策略。  </p><p>  主要内容包括：</p><ul><li>策略引用：引用WAF和IPS的策略，设置受保护服务器组。</li><li>Web安全策略：配置Web应用安全策略。</li><li>入侵防护策略：配置入侵防护相关策略。</li><li>Web漏洞扫描：管理员可以制定扫描任务，系统就会根据配置进行扫描，并生成扫描报告。扫描报告支持管理员在线查看、导出、订阅。</li><li>自学习：配置如何启用或禁用自学习模式，如何进行相关的配置，以及查看自学习的结果。</li><li>防DDOS/CC攻击：配置是否启用HTTP请求限制、TCP包攻击检测、UDP包攻击检测和ICMP包攻击检测。</li><li>全局黑白名单：配置对Web服务器IP访问进行限制。</li><li>动态攻击黑名单：配置主要对具有疑似攻击行为的IP进行二次的评定。</li><li>Web shell监测：配置是否检查服务器中被植入了Web shell代码。</li></ul><p>  <font size="2"><strong>安全策略——策略引用</strong></font>  </p><p>  点击安全策略 &gt; 策略引用进入界面，该界面用于应用配置完成的Web应用安全策略及入侵防御策略，界面如下：  </p><p><img src="policy1.jpg" alt="">  </p><p>  ≯ 上联接口：当部署为透明代理模式时，选择流量的入接口；当部署为反向代理模式时，选择veth0；<br>  ≯ 当部署为旁路监听模式时，选择流量的镜像口；<br>  ≯ 入侵防护策略：可以选择内置的或用户自定义的入侵防护策略；<br>  ≯ Web可以选择内置的或用户自定义的Web安全策略；<br>  ≯ 服务器安全组：添加需要保护的服务器或虚拟主机域名。    </p><blockquote><p>注：设置完上述各项后，需要开启该策略引用项，此此时策略才生效。  </p></blockquote><p>  管理员可以添加、修改和删除规则引用，具体步骤为：<br>  (1) 添加规则，点击“添加”按钮，会自动出现一条规则，管理员需要为该条规则选择上联接口（非信任接口）和IPS与WAF策略，且点击服务器安全组下方的图标添加需要防护的服务器列表。<br>  (2)编辑服务器群组，在“服务器列表”处配置需要受保护的Web服务器和FTP服务器的IP地址及子网掩码，以及服务器使用的协议类型及端口号。如下图所示。</p><p><img src="policy2.jpg" alt="">  </p><p>  在“IP/掩码”处设置Web服务器或FTP服务器的IP地址及其子网掩码（支持IPV4和IPV6格式的地址），并选择服务器需要进行检测的协议，及其使用的端口号，然后点击“添加”按钮即可。<br>  点击“删除”下的按钮一栏对应的按钮可以删除该表项。<br>  当Web服务器上存在虚拟主机时，需要在“虚拟主机域名列表”处设定保护的Web服务器的IP地址、域名、协议及端口号之间的对应关系。如下图所示。</p><p><img src="policy3.jpg" alt="">  </p><p>  在“IP/掩码”处设置Web服务器的IP地址及其子网掩码，支持IPV4和IPV6格式的地址，在“域名”处输入Web服务器的域名，并在“协议端口”处选择Web服务器使用的协议及其端口号，然后点击“添加”按钮即可。<br>  点击“删除”一栏对应的按钮可以删除该表项。</p><blockquote><p>注：编辑完服务器安全组后，需要点击此页面下方的“应用”按钮才生效。</p></blockquote><p>(3)启用安全规则，点击操作中的“▶”启动该条规则，点击“■”暂停该条规则。</p><blockquote><p><font size="4" color="green">提醒：</font><br> 当前，流量如果从上联接口进入WAF，会进行规则检测，之后会从上往下匹配服务器安全组，匹配上后则按照该条策略引用中设置的入侵防护策略和WEB安全策略进行检测。</p></blockquote><ul><li>此处添加的IP地址，无论是透明部署模式还是反向代理模式，，都是指真实服务器的IP。</li><li>虚拟主机域名作用：如受保护的服务器IP对应多个域名，且实际需要对其中部分域名的流量进行策略检查，此时可只在虚拟主机域名中添加相关域名。  </li></ul><blockquote><p>注：反代模式下，添加虚拟主机域名时，域名映射的IP应该是该服务器的代理IP。  </p></blockquote><p>  <font size="2"><strong>安全策略——Web安全策略</strong></font> </p><p>  Web安全策略用于设置一系列安全配置文件，在不同的文件中可以设置不同的检测策略：可以检测不同的攻击类型，并对每一种攻击类型设置不同的检测参数。然后在不同的规则中引用不同的安全策略，从而对不同的服务器组提供不同的安全保护方案。  </p><p>  选择“安全策略 &gt; Web安全策略”，可以对Web安全策略进行设置；WAF自带一条名称为default-profile的默认Web安全策略，该策略选项动作全部为仅记录日志，不进行阻断；该策略用于用户初次上线，只检测不阻断的工作方式，待运行一段时间后，基于日志分析启用安全策略；该策略可以在策略引用中进行引用操作；  </p><p><img src="policy0.jpg" alt="">  </p><p>  点击添加按钮，可以自定义策略,也可以复制现有的策略；</p><p><img src="policy4.jpg" alt="">  </p><p>  点击操作下方的编辑图标按钮，可以进入各项具体策略的设置页面，根据实际的需要，可启用/不启用各项策略以及编辑各项具体参数。  </p><p>  <font size="2"><strong>安全策略——Web安全策略——基本特征库</strong></font>  </p><p>  WAF内置了9种类别400多条的基本特征，管理员可针对这些特征条目进行启用/不启用，转发阻断等一系列操作。  </p><p>  选择“安全策略 &gt; Web安全策略”，对于需要编辑的一条策略，点击编辑按钮，进入“基本特征库”页面，在该页面可以设置特征库中各项规则的动作、是否记录日志、启用状态等，根据不同条件查询具体的某个规则。  </p><p><img src="waf-ips.jpg" alt="">  </p><p>  表2-2  WAF特征库操作说明</p><table> <tbody><tr>  <th width="100">参数</th>  <th width="100">说明</th> </tr> <tr>  <th>过滤显示</th>  <th align="left">输入过滤条件显示需要查看的特征条目。</th> </tr> <tr>  <th>动作</th>  <th align="left">分为阻断、放行、告警或重定向。</th> </tr> <tr>  <th>日志</th>  <th align="left">记录、不记录。</th> </tr> <tr>  <th>操作</th>  <th align="left">左边操作按钮为为该条特征添加例外主机，点击跳转到“添加例外”界面，右边按钮为查看描述，点击查看该条特征的详细描述。</th> </tr></tbody></table><h4 id="6-WAF维护"><a href="#6-WAF维护" class="headerlink" title="6. WAF维护"></a>6. WAF维护</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>H3CSE-Security(GB0-550)-第一章 部署内容安全概述</title>
      <link href="/2020/03/24/h3cse-security-gb0-550-di-yi-zhang-bu-shu-nei-rong-an-quan-gai-shu/"/>
      <url>/2020/03/24/h3cse-security-gb0-550-di-yi-zhang-bu-shu-nei-rong-an-quan-gai-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-部署内容安全概述"><a href="#第一章-部署内容安全概述" class="headerlink" title="第一章 部署内容安全概述"></a><center>第一章 部署内容安全概述</center></h3><h4 id="emsp-1-部署内容安全概述"><a href="#emsp-1-部署内容安全概述" class="headerlink" title=" 1. 部署内容安全概述"></a> 1. 部署内容安全概述</h4><p> 1）何为内容安全?  </p><p>  内容安全顾名思义就是提供应用层安全防护</p>   2）内容安全所面临的挑战   <ul><li>攻击方式、攻击手段、攻击来源多样化，难以防范；  </li><li>不同形式的网络攻击层出不穷。内容安全随时在面临着危险；  </li><li>国内企业信息安全体系建设处于初级阶段；  </li></ul><h4 id="emsp-2-内容安全风险"><a href="#emsp-2-内容安全风险" class="headerlink" title=" 2.内容安全风险"></a> 2.内容安全风险</h4><p> 1) DDO攻击  </p><p><img src="ddos.png" alt="DDoS攻击示意图">  </p><p> DDoS是Distributed Denial of Service的简称，即分布式拒绝服务，此攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发起DDoS攻击，从而成倍地提供拒绝服务攻击的威力。   </p><p> Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。不同于其他的留有木马后门或劫持数据的方式，DoS攻击并不威胁敏感数据，只是使合法用户不能获得应用的服务。  </p><p> 2) Web应用风险  </p><p> 十大Web应用安全风险  </p><p>  A1—注入 （Injection）：是指攻击者通过输入恶意数据，从而达到在Web服务器环境下运行任意指令的目的。比较有名的是SQL、XML和LDAP注入。在应用程序中，通过对用户输入的特定字符进行转义，可以预防恶意数据的注入。</p><p>  A2—跨站脚本 （Cross-Site  Scripting，XSS）：是指应用程序在没有对用户输入进行正确验证的情况下，将这些输入直接输出到了Web浏览器中，而这些输入一旦被浏览器执行，将有可能导致会话劫持、cookie窃取或者Web站点数据被污染。在应用程序中，通过对HTML、JavaScript或者CSS输出中不受信任的元字符进行转义，可以预防跨站脚本。</p><p>  A3—无效的验证和会话管理 （Broken Authentication and Session Management）：使用不安全的验证和会话管理程序，可能会导致用户账户被劫持，或者导致会话token可预测。开发一个健壮的验证和会话管理程序可以预防此类攻击。我们强烈建议使用加密、散列和基于SSL或者TLS的安全数据连接。</p><p>  A4—不安全的直接对象引用： 如果应用程序提供其内部对象的直接引用，并且没有进行正确验证，那么可能会导致攻击者操纵这些引用并访问未经授权的数据。这个内部对象可能是用户账户的参数值、文件名或者目录。在访问控制检查（access control  check）完成之前，限制所有用户可访问的内部对象，可以确保对相关对象的每一次访问都是经过验证的。</p><p>  A5—跨站请求伪造 （Cross-Site  Request  Forgery ，CSRF）：是指在存在漏洞的Web应用中，强迫经过验证的用户去运行伪造的HTTP请求。这些恶意请求都是在合法的用户会话中被执行的，因此无法检测到。通过在每一个用户会话中都生成一个不可预测的token，然后每次发送HTTP请求时都绑定这个token，可以减轻CSRF攻击的危害。</p><p>  A6—错误的安全配置 （Security Misconfiguration）：有时候，使用默认的安全配置可能会导致应用程序容易遭受多种攻击。在已经部署的应用、Web服务器、数据库服务器、操作系统、代码库以及所有和应用程序相关的组件中，都应该使用现有的最佳安全配置，这一点至关重要。通过不断地进行软件更新、打补丁、从严制定应用环境中的安全规则，可以实现安全的应用程序配置。</p><p>  A7—不安全的密码存储 （Insecure Cryptographic  Storage）：那些没有对敏感数据（例如医保信息、信用卡交易、个人信息、认证细节等）使用密码保护机制的应用程序，都可以归到这类中。通过使用健壮的标准加密算法或散列算法，可以保障数据的安全性。</p><p>  A8—失败的URL访问权限限制 （Failure to Restrict URL Access）：如果Web应用程序没有对URL的访问进行权限检查，那么攻击者可能可以访问未经授权的网页。为了解决这个问题，需要运用合适的身份证明和授权控制机制来限制对私有URL的访问，同时需要为那些可以访问高敏感性数据的特殊用户和角色开发一套合适的权限控制策略。</p><p>  A9—薄弱的传输层保护 （Insufficient Transport Layer Protection）：使用低强度的加密算法、无效的安全证书以及不恰当的身份证明控制机制，会破坏数据的机密性和完整性。这些应用数据将有可能遭到流量窃听和篡改攻击。通过在传输所有敏感网页时使用SSL协议，并使用权威认证机构颁布的合法数字证书，可以解决这类安全问题。</p><p>  A10—未验证的重定向和转发 （Unvalidated Redirects and Forwards）：很多Web应用程序使用动态参数将用户重定向或者转到某个特定的URL上。攻击者可以通过相同的方法伪造一个恶意的URL，将用户重定向到钓鱼网站或者恶意站点上。这种攻击方式还可以用于将请求转发到本地未经授权的网页上。要想避免非法重定向和转发，只需要简单地验证请求中的参数和发出请求的用户的访问权限。</p><p> 3）漏洞  </p><p> 漏洞是指一个系统存在的弱点或缺陷，系统对特定威胁攻击或危险事件的敏感性，或进行攻击的威胁作用的可能性。漏洞可能来自应用软件或操作系统设计时的缺陷或编码时产生的错误，也可能来自业务在交互处理过程中的设计缺陷或逻辑流程上的不合理之处。这些缺陷、错误或不合理之处可能被有意或无意地利用，从而对一个组织的资产或运行造成不利影响，如信息系统被攻击或控制，重要资料被窃取，用户数据被篡改，系统被作为入侵其他主机系统的跳板。从目前发现的漏洞来看，应用软件中的漏洞远远多于操作系统中的漏洞，特别是WEB应用系统中的漏洞更是占信息系统漏洞中的绝大多数。  </p><h4 id="emsp-3-内容安全需求"><a href="#emsp-3-内容安全需求" class="headerlink" title=" 3.内容安全需求"></a> 3.内容安全需求</h4><p> 安全隔离与信息交换<br> 运维安全<br> 数据库安全<br> 运维审计安全<br> Web应用安全</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>17-Windows Server 2012 R2——Hyper-V搭建</title>
      <link href="/2018/09/28/17-windows-server-2012-r2-hyper-v-da-jian/"/>
      <url>/2018/09/28/17-windows-server-2012-r2-hyper-v-da-jian/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>16-Windows Server 2012 R2——虚拟专用网VPN配置</title>
      <link href="/2018/09/27/16-windows-server-2012-r2-xu-ni-zhuan-yong-wang-vpn-pei-zhi/"/>
      <url>/2018/09/27/16-windows-server-2012-r2-xu-ni-zhuan-yong-wang-vpn-pei-zhi/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>15-Windows Server 2012 R2——网络地址转换NAT</title>
      <link href="/2018/09/26/15-windows-server-2012-r2-wang-luo-di-zhi-zhuan-huan-nat/"/>
      <url>/2018/09/26/15-windows-server-2012-r2-wang-luo-di-zhi-zhuan-huan-nat/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>14-Windows Server 2012 R2——路由器与网桥配置</title>
      <link href="/2018/09/25/14-windows-server-2012-r2-lu-you-qi-yu-wang-qiao-pei-zhi/"/>
      <url>/2018/09/25/14-windows-server-2012-r2-lu-you-qi-yu-wang-qiao-pei-zhi/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>13-Windows Server 2012 R2——SMTP服务器配置</title>
      <link href="/2018/09/24/13-windows-server-2012-r2-smtp-fu-wu-qi-pei-zhi/"/>
      <url>/2018/09/24/13-windows-server-2012-r2-smtp-fu-wu-qi-pei-zhi/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>12-Windows Server 2012 R2——IIS服务器搭建</title>
      <link href="/2018/09/23/12-windows-server-2012-r2-iis-fu-wu-qi-da-jian/"/>
      <url>/2018/09/23/12-windows-server-2012-r2-iis-fu-wu-qi-da-jian/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11-Windows Server 2012 R2——Radius服务器搭建</title>
      <link href="/2018/09/22/11-windows-server-2012-r2-radius-fu-wu-qi-da-jian/"/>
      <url>/2018/09/22/11-windows-server-2012-r2-radius-fu-wu-qi-da-jian/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>10-Windows Server 2012 R2——故障转移集群配置</title>
      <link href="/2018/09/21/10-windows-server-2012-r2-gu-zhang-zhuan-yi-ji-qun-pei-zhi/"/>
      <url>/2018/09/21/10-windows-server-2012-r2-gu-zhang-zhuan-yi-ji-qun-pei-zhi/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>09-Windows Server 2012 R2——文件服务器</title>
      <link href="/2018/09/20/09-windows-server-2012-r2-wen-jian-fu-wu-qi/"/>
      <url>/2018/09/20/09-windows-server-2012-r2-wen-jian-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>08-Windows Server 2012 R2——Ser-U部署</title>
      <link href="/2018/09/19/08-windows-server-2012-r2-ser-u-bu-shu/"/>
      <url>/2018/09/19/08-windows-server-2012-r2-ser-u-bu-shu/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>07-Windows Server 2012 R2——FTP服务器搭建</title>
      <link href="/2018/09/18/07-windows-server-2012-r2-ftp-fu-wu-qi-da-jian/"/>
      <url>/2018/09/18/07-windows-server-2012-r2-ftp-fu-wu-qi-da-jian/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>06-Windows Server 2012 R2——DHCP服务器搭建</title>
      <link href="/2018/09/17/06-windows-server-2012-r2-dhcp-fu-wu-qi-da-jian/"/>
      <url>/2018/09/17/06-windows-server-2012-r2-dhcp-fu-wu-qi-da-jian/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>05-Windows Server 2012 R2——DNS服务器搭建</title>
      <link href="/2018/09/16/05-windows-server-2012-r2-dns-fu-wu-qi-da-jian/"/>
      <url>/2018/09/16/05-windows-server-2012-r2-dns-fu-wu-qi-da-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="05-Windows-Server-2012-R2——DNS服务器搭建"><a href="#05-Windows-Server-2012-R2——DNS服务器搭建" class="headerlink" title="05-Windows Server 2012 R2——DNS服务器搭建"></a><center>05-Windows Server 2012 R2——DNS服务器搭建</center></h3><p>  <strong>实验环境：</strong></p><p>   H3C CAS 5.0 (E0503)  </p><p>  <strong>DNS主服务器端硬件配置</strong>  </p><p>   操作系统：Windows Server 2012 R2<br>   网卡：10.75.75.254/24<br>   磁盘：80GB<br>   内存：6GB</p><p>  <strong>DNS备服务器端硬件配置</strong>  </p><p>   操作系统：Windows Server 2012 R2<br>   网卡：10.75.75.253/24<br>   磁盘：80GB<br>   内存：6GB</p><h4 id="一、DNS主服务器搭建"><a href="#一、DNS主服务器搭建" class="headerlink" title="一、DNS主服务器搭建"></a>一、DNS主服务器搭建</h4><p>  <strong>步骤1</strong> 打开<code>服务器管理器</code>，点击<code>添加角色和功能</code>  </p><p><img src="001.png" alt=""></p><p>  <strong>步骤2</strong> 在安装类型页面，选择<code>基于角色或基于功能的安装</code>，击<code>下一步</code>；   </p><p><img src="002.png" alt=""></p><p>  <strong>步骤3</strong> 服务器选择，选择<code>从服务器池中选择服务器</code>，选择本服务器，点击<code>下一步</code>；  </p><p><img src="003.png" alt=""></p><p>  <strong>步骤4</strong> 在添加服务器角色界面，选择<code>DNS服务器</code>，在新弹出的窗口，点击<code>添加功能</code>，然后点击<code>下一步</code>；  </p><p><img src="004.png" alt=""></p><p>  <strong>步骤5</strong> 功能界面，选择默认方式，直接点击<code>下一步</code>；   </p><p><img src="005.png" alt="">   </p><p>  <strong>步骤6</strong> 在DNS服务器界面，阅读DNS服务器说明、注意事项。点击<code>下一步</code>；  </p><p><img src="006.png" alt=""></p><p>  <strong>步骤7</strong> 确认所选安装内容，点击<code>下一步</code>；   </p><p><img src="007.png" alt=""></p><h4 id="二、配置DNS服务器"><a href="#二、配置DNS服务器" class="headerlink" title="二、配置DNS服务器"></a>二、配置DNS服务器</h4><p>  安装好DNS后，需要进一步对DNS服务器进行配置。目前，我需要将主DNS服务器的IP地址解析到自定义域名<a href="http://www.panakot.cn上。" target="_blank" rel="noopener">www.panakot.cn上。</a>    </p><p>  <strong>2.1</strong> 建立主要区域  </p><p>  DNS客户端所提出的查询请求绝大部分属于正向查询，也就是从主机名来查询IP地址。  </p><p>  <strong>Step 1</strong> 按<code>Windows</code>键，切换到<code>开始</code>菜单，点击<code>管理工具</code>,在管理工具界面双击<code>DNS</code>；  </p><p><img src="008.png" alt="">  </p><p>  <strong>Step 2</strong> 在DNS管理器界面，选中并右击<code>正向查找区域</code>—-&gt; <code>新建区域</code></p><p><img src="009.png" alt=""></p><p>  <strong>Step 3</strong> 在新建区域向导界面，点击<code>下一步</code>按钮，选择<code>主要区域</code>，单击<code>下一步</code>；  </p><p><img src="010.png" alt=""><br><img src="011.png" alt=""></p><p>  <strong>Step 4</strong> 在区域名称处输入自定义的区域名称（例如panakot.local）,单击<code>下一步</code>；  </p><p><img src="012.png" alt=""> </p><p>  <strong>Step 5</strong> 在创建区域文件界面，采用默认的区域文件名。如果要使用现有的区域文件名，就将该文件拷贝到%Systemroot%\system32\dns文件夹下，然后选中<code>使用此现存文件</code>，并输入文件名,单击<code>下一步</code>；  </p><p><img src="013.png" alt=""></p><p>  <strong>Step 6</strong> 在动态更新页面，选择默认<code>不允许动态更新</code>，点击<code>下一步</code>；  </p><p><img src="014.png" alt=""> </p><p>  <strong>Step 7</strong> 出现<code>正在完成新建区域向导</code>界面时，单击<code>完成</code>按钮；  </p><p><img src="015.png" alt=""> </p><p>  <strong>Step 8</strong> 下图所示就是我们所建立的区域；  </p><p><img src="016.png" alt=""></p><h4 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Server 2012 R2 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-Windows Server 2012 R2——AD域控制器搭建及配置教程</title>
      <link href="/2018/09/15/04-windows-server-2012-r2-ad-yu-kong-zhi-qi-da-jian-ji-pei-zhi-jiao-cheng/"/>
      <url>/2018/09/15/04-windows-server-2012-r2-ad-yu-kong-zhi-qi-da-jian-ji-pei-zhi-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows-Server-2012-R2搭建AD域及配置教程"><a href="#Windows-Server-2012-R2搭建AD域及配置教程" class="headerlink" title="Windows Server 2012 R2搭建AD域及配置教程"></a><center>Windows Server 2012 R2搭建AD域及配置教程</center></h2><p> 关于Windows Server 2012 R2操作系统的安装，这里将不做记录，目前还没有安装服务器操作系统，可以参考<a href="">《Vmware Workstation 15 pro 安装Windows Server 2012 R2操作系统详细教程》</a>  </p><p>  <strong>实验环境：</strong></p><p>   H3C CAS 5.0 (E0503)  </p><p>  <strong>AD主服务器端硬件配置</strong>  </p><p>   操作系统：Windows Server 2012 R2<br>   网卡：10.75.75.254/24<br>   磁盘：80GB<br>   内存：6GB</p><p>  <strong>AD从服务器硬件配置</strong>  </p><p>   操作系统：Windows Server 2012 R2<br>   网卡：10.75.75.253/24<br>   磁盘：80GB<br>   内存：6GB </p><p>  <strong>客户端硬件配置</strong>  </p><p>   操作系统：Windows 10<br>   网卡：10.75.75.123/24<br>   磁盘：80GB<br>   内存：4GB </p><h3 id="一、部署主AD域控制器（部署单域控，按照以下步骤配置，配置双域控，请查阅全文。）"><a href="#一、部署主AD域控制器（部署单域控，按照以下步骤配置，配置双域控，请查阅全文。）" class="headerlink" title="一、部署主AD域控制器（部署单域控，按照以下步骤配置，配置双域控，请查阅全文。）"></a>一、部署主AD域控制器（部署单域控，按照以下步骤配置，配置双域控，请查阅全文。）</h3><p> 在部署AD域控制器前，我们首先需要将Windows Server 2012 R2操作系统的网络相关配置规划好，网卡（单端口、双端口网卡绑定）、服务器IP地址、子网掩码、默认网关、DNS服务器地址，由于该服务器既要充当AD的角色，也要充当网络DNS服务器的角色，因此DNS地址填写自己的IP地址，备用DNS填写从域控制器IP地址。（此次搭建AD域控制器采用双机方式，DNS部署不在这里展现，关于DNS服务器的搭建部署，请参考<a href="">《Windows Server 2012 R2——DNS服务器搭建》</a>）,操作系统网络信息如下图所示：  </p><p><img src="01.png" alt="">  </p><p> <strong>步骤1</strong>、修改主机名，单击“这台电脑”右键“属性”，在系统页面点击“更改设置”，“计算机名–更改”。计算机名随意，只是为了标识某一台设备而定义的名称，方便记忆。我这里输入“domain”;更改完计算机名会提示重启服务器，点击“立即重新启动”；  </p><p><img src="02.png" alt="">  </p><p>  <strong>步骤2</strong>、点击Windows Server 2012 R2桌面左下角的“服务器管理器”，打开后，显示界面如图所示：    </p><p><img src="010.png" alt="">  </p><p>  <strong>步骤3</strong>、点击“管理” &gt; “添加角色和功能”，会弹出“添加角色和功能向导” ，点击下一步；   </p><p><img src="03.png" alt=""><br><img src="04.png" alt="">  </p><p> <strong>步骤4</strong>、这里选择“基于角色和基于功能的安装”，点击下一步；   </p><p><img src="05.png" alt="">  </p><p> <strong>步骤5</strong>、从服务器池中选择服务器，这里选择默认，点击“下一步”；假如您需要针对其他服务器主机安装AD角色，这里可以选择您需要的主机，点击下一步。  </p><p><img src="06.png" alt="">    </p><p>  <strong>步骤6</strong>、角色选择，勾选“Active Directory域服务”，当勾选这个选项后，会弹出“添加Active Directory域服务所需的功能”，点击“添加功能”，然后返回到角色选择窗口，点击“下一步”；  </p><p><img src="07.png" alt=""><br><img src="08.png" alt="">  </p><p>  <strong>步骤7</strong>、功能选择页面不需要做任何选择，直接点击“下一步”即可；  </p><p><img src="09.png" alt=""></p><p>  <strong>步骤8</strong>、这里介绍AD角色功能的注意事项，点击“下一步”；  </p><p><img src="10.png" alt=""></p><p>  <strong>步骤9</strong>、勾选“如果有需要，自动重新启动目标服务器”，点击安装；  </p><p><img src="11.png" alt=""></p><p>  <strong>步骤10</strong>、功能安装成功后，但不代表我们就将AD域控制器完全安装好了，这里点击“将此服务器提升为域控制器”  </p><p><img src="12.png" alt=""></p><p>  <strong>步骤11</strong>、在新弹出的“Active Directory域服务配置向导”，选择“添加新林(F)”,根域名处填写相应的域名，点击“下一步”；  </p><p><img src="012.png" alt=""></p><p>  <strong>步骤12</strong>、在域控制器选项处，选择新林和根域的功能级别，选择指定域控制器功能：DNS/GC/RODC，这里选择默认，然后在下面设置DSRM密码，点击“下一步”；  </p><p><img src="13.png" alt=""></p><p>  <strong>步骤13</strong>、直接点击“下一步”，由于不需要委派DNS，所以这里不需要设置；  </p><p><img src="013.png" alt="">  </p><p>  <strong>步骤14</strong>、配置NetBios域名，若没有特殊需求，默认即可，点击“下一步”；  </p><p><img src="14.png" alt=""></p><p>  <strong>步骤15</strong>、配置日志，数据库，SYSVOL路径，若没有特殊需求，默认就可以，点击“下一步”；  </p><p><img src="15.png" alt=""></p><p>  <strong>步骤16</strong>、查看配置信息，若没有任何问题，直接点击“下一步”；  </p><p><img src="16.png" alt=""></p><p>  <strong>步骤17</strong>、先决条件检查，检查是否满足条件，条件满足后就可以直接点击“安装”；  </p><p><img src="19.png" alt="">  </p><p>  <strong>步骤18</strong>、等待Active Directory的安装，需要重启服务器；   </p><p><img src="17.png" alt=""></p><p>  <strong>步骤19</strong>、重启完成后，就可以看到AD角色已经安装完成。  </p><p><img src="18.png" alt=""></p><h3 id="二、部署从域控制器"><a href="#二、部署从域控制器" class="headerlink" title="二、部署从域控制器"></a>二、部署从域控制器</h3><p> 首先配置从域控制器服务器的IP地址、子网掩码、默认网关的参数。由于该服务器既要充当从AD域控制器角色，也要充当网络中备用DNS的角色，所以首选DNS填写主域控制器的IP地址，备用DNS填写自己的IP地址。网络信息如下图所示：  </p><p><img src="20.png" alt="">  </p><p> <font size="5" color="red">注：从域控制器步骤2～10和主域控制器的配置步骤雷同，可以直接跳到步骤11。</font>  </p><p>  <strong>步骤1</strong>、修改主机名，单击“这台电脑”右键“属性”，在系统页面点击“更改设置”，“计算机名–更改”。计算机名随意，只是为了标识某一台设备而定义的名称，方便记忆。我这里输入“domainbackup”;更改完计算机名会提示重启服务器，点击“立即重新启动”；  </p><p><img src="21.png" alt="">  </p><p>  <strong>步骤2</strong>、点击Windows Server 2012 R2桌面左下角的“服务器管理器”，打开后，显示界面如图所示：    </p><p><img src="010.png" alt="">  </p><p>  <strong>步骤3</strong>、点击“管理” &gt; “添加角色和功能”，会弹出“添加角色和功能向导” ，点击下一步；   </p><p><img src="03.png" alt=""><br><img src="004.png" alt="">  </p><p>  <strong>步骤4</strong>、这里选择“基于角色和基于功能的安装”，点击下一步；   </p><p><img src="005.png" alt="">  </p><p>  <strong>步骤5</strong>、从服务器池中选择服务器，这里选择默认，点击“下一步”；假如您需要针对其他服务器主机安装AD角色，这里可以选择您需要的主机，点击下一步。  </p><p><img src="22.png" alt="">  </p><p>  <strong>步骤6</strong>、角色选择，勾选“Active Directory域服务”，当勾选这个选项后，会弹出“添加Active Directory域服务所需的功能”，点击“添加功能”，然后返回到角色选择窗口，点击“下一步”；  </p><p><img src="007.png" alt=""><br><img src="008.png" alt="">  </p><p>  <strong>步骤7</strong>、功能选择页面不需要做任何选择，直接点击“下一步”即可；  </p><p><img src="009.png" alt=""></p><p>  <strong>步骤8</strong>、这里介绍AD角色功能的注意事项，点击“下一步”；  </p><p><img src="0010.png" alt=""></p><p>  <strong>步骤9</strong>、勾选“如果有需要，自动重新启动目标服务器”，点击安装；  </p><p><img src="011.png" alt=""></p><p>  <strong>步骤10</strong>、功能安装成功后，但不代表我们就将AD域控制器完全安装好了，这里点击“将此服务器提升为域控制器”  </p><p><img src="0012.png" alt="">  </p><p>  <strong>步骤11</strong>、在新弹出的“Active Directory域服务配置向导”，选择“将域控制器添加到现有域(D)”,点击选择，然后在弹出的“Windows安全”栏中输入主域控制器的域控制器管理员账号和密码，点击“确定”，在弹出的窗口选中主域控制器的域名，点击“确定”，回到“部署配置”选项，点击“下一步”；   </p><p><img src="23.png" alt=""><br><img src="24.png" alt=""><br><img src="25.png" alt=""><br><img src="26.png" alt="">  </p><p>  <strong>步骤12</strong>、由于是从域控制器，所以在“域控制器选项”中选择域名系统（DNS）服务器、全局编录（GC)功能，设置DSRM密码。为方便记忆，填写和主域控制器一样的DSRM密码。 </p><p><img src="27.png" alt="">  </p><p>  <strong>步骤13</strong>、直接点击“下一步”，由于不需要委派DNS，所以这里不需要设置；  </p><p><img src="28.png" alt="">  </p><p>  <strong>步骤14</strong>、选择从主域控制器复制数据，复制来自“domain.panakot.com”，点击“下一步”；  </p><p><img src="29.png" alt="">  </p><p>  <strong>步骤15</strong>、配置日志，数据库，SYSVOL路径，若没有特殊需求，默认就可以，点击“下一步”；  </p><p><img src="30.png" alt="">  </p><p>  <strong>步骤16</strong>、查看配置信息，若没有任何问题，直接点击“下一步”； </p><p><img src="31.png" alt="">  </p><p>  <strong>步骤17</strong>、先决条件检查，检查是否满足条件，条件满足后就可以直接点击“安装”；  </p><p><img src="32.png" alt="">  </p><p>  <strong>步骤18</strong>、等待Active Directory的安装，需要重启服务器；  </p><p><img src="33.png" alt="">  </p><p> 到这里从域控制器也配置完成了，等待服务器重启。</p><h3 id="三、验证AD域控制器是否安装成功"><a href="#三、验证AD域控制器是否安装成功" class="headerlink" title="三、验证AD域控制器是否安装成功"></a>三、验证AD域控制器是否安装成功</h3><p>  <strong>步骤1</strong>、运行CMD命令行，输入“netdom query fsmo”,这时会显示五种角色都已经安装成功；  </p><p><img src="34.png" alt="">  </p><p>  <strong>步骤2</strong>、若要进一步验证AD是否安装正确，可以使用DCDIAG /a命令行；  </p><p><img src="35.png" alt="">  </p><p>  <strong>步骤3</strong>、使用Repadmin诊断工具检查目录复制问题，包括管理和修改复制拓扑，强制复制事件和显示复制元数据与最新矢量，使用命令<code>repadmin /showreps</code>。  </p><p><img src="36.png" alt="">  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Server 2012 R2 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-Windows Server 2012 R2——多路径配置</title>
      <link href="/2018/09/14/03-windows-server-2012-r2-duo-lu-jing-pei-zhi/"/>
      <url>/2018/09/14/03-windows-server-2012-r2-duo-lu-jing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="03-Windows-Server-2012-R2——多路径配置"><a href="#03-Windows-Server-2012-R2——多路径配置" class="headerlink" title="03-Windows Server 2012 R2——多路径配置"></a><center>03-Windows Server 2012 R2——多路径配置</center></h3><p>  <strong>实验环境：</strong></p><p>   H3C CAS 5.0 (E0503)  </p><p>  <strong>iSCSI服务器端硬件配置</strong>  </p><p>   操作系统：Windows Server 2012 R2<br>   网卡1：10.75.75.54/24<br>   网卡2：10.75.75.55/24<br>   磁盘：80GB<br>   内存：6GB</p><p>  <strong>iSCSI客户端硬件配置</strong>  </p><p>   操作系统：Windows Server 2012 R2<br>   网卡1：10.75.75.67/24<br>   网卡2：10.75.75.68/24<br>   磁盘：80GB<br>   内存：6GB </p><p>  <strong><font color="red">注：无需配置网关和DNS,仅用于存储使用</font></strong>   </p><p>   <strong>环境草图</strong></p><p><img src="topol.png" alt=""></p><p>  关于部署iSCSI虚拟磁盘请参考<a href="">《02-Windows Server 2012 R2——部署iSCSI共享磁盘》</a>进行部署，添加访问服务器的客户机的两个IP地址。</p><h4 id="1-配置iSCSI发起程序"><a href="#1-配置iSCSI发起程序" class="headerlink" title="1. 配置iSCSI发起程序"></a>1. 配置iSCSI发起程序</h4><p>  打开服务器管理器 &gt;&gt; 工具 &gt;&gt; iSCSI发起程序，在iSCSI发起程序，在<code>目标</code>选项卡中，输入iSCSI服务器的IP地址10.75.75.54，点击“快速连接”，找到目标iSCSI服务器，点击“完成”。在<code>发现</code>选项卡中，可以查看到已经查找到的目标服务器；  </p><p><img src="004.png" alt=""><br><img src="008.png" alt=""></p><p>  添加完两个iSCSI服务器IP地址后，我们在<code>设备管理器</code>中的<code>硬盘驱动器</code>可以看到两块硬盘驱动；</p><p><img src="010.png" alt=""></p><h4 id="2-客户机部署iSCSI多路径"><a href="#2-客户机部署iSCSI多路径" class="headerlink" title="2. 客户机部署iSCSI多路径"></a>2. 客户机部署iSCSI多路径</h4><p>  打开服务器管理器 &gt;&gt; 添加功能和角色  </p><p><img src="001.png" alt=""></p><p>  关于安装类型和服务器选择以及服务器角色，直接点击“下一步”，在<code>功能</code>界面，选择<code>多路径I/O</code>，点击“下一步”；</p><p><img src="002.png" alt=""></p><p>  确认多路径，点击“安装”  </p><p><img src="003.png" alt="">  </p><h4 id="3-配置MPIO"><a href="#3-配置MPIO" class="headerlink" title="3. 配置MPIO"></a>3. 配置MPIO</h4><p>  打开服务管理器 &gt;&gt; 工具 &gt;&gt; MPIO   </p><p><img src="006.png" alt="">  </p><p>  在发现多路径选项卡中，勾选<code>添加对iSCSI设备的支持</code>，点击“添加”，会提示需要重启，点击“是”；</p><p><img src="007.png" alt="">  </p><p>  iSCSI客户机重启完成后，查看MPIO属性时，可以看到新增的iSCSI设备信息；  </p><p><img src="005.png" alt=""></p><p>  编辑MPIO属性相关信息；打开iSCSI发起程序，选中已发现的目标，点击<code>属性</code>，</p><p><img src="014.png" alt=""></p><p>  添加会话，并在会话中勾选多路径，之后点击“高级”选项;  </p><p><img src="015.png" alt=""> </p><p>  在高级设置中，修改连接方式，将其配置如下图方式，实际情况按照实际部署而定，这里将10.75.75.67添加到会话中；  </p><p><img src="016.png" alt=""></p><p>  再次添加会话，将10.75.75.68添加到会话中，启动多路径；  </p><p><img src="017.png" alt=""></p><p>  选中两个刚添加的会话，点击“设备”；   </p><p><img src="018.png" alt=""> </p><p>  在<code>设备</code>窗口中，点击“MPIO”；  </p><p><img src="019.png" alt=""></p><p>  将MPIO策略勾选为“协商会议”，这里的策略根据实际情况选择。</p><p><img src="020.png" alt=""></p><p>  <font color="read"><strong>补充说明：</strong></font>  </p><p>  <font color="read">(1)仅故障转移（failover only）  </font></p><font color="read"><p>故障转移策略使用一个活动路径并指定所有其他路径为待机状态。在活动路径出现故障时，将采用循环法尝试待机路径，直至找到可用的路径为止。通俗来讲，就是一条路径挂了，切到另一条。它是自动切换，active/standby模式；  </p><p>  (2)协商会议（round robin）  </p><p>循环策略尝试将传入的请求平均分配到所有处理路径中。这个模式就是负载均衡，每条路径都会写IO，不能浪费服务器性能，active/active模式；  </p><p>  (3)带子集的协商会议  </p><p>子集循环策略只对指定为活动的路径执行循环策略。在所有活动路径都出现故障时，将采用循环法尝试待机路径。比协商会议更高级一点，储存的三种工作模式中的一种，主要是存储控制那一条路径，而不是客户端。主要是提高存储的读写性能和可靠性。 active/active模式；</p><p>  允许应用程序指定要以轮循机制方式使用的路径集以及备用路径集的负载平衡策略。DSM 使用来自主路径池的路径处理请求，只要其中至少有一个路径可用即可。仅当所有主路径发生故障时，DSM 才使用备用路径。例如，假设有 4 个路径：A、B、C 和 D，路径 A、B 和 C 被列为主路径，而 D 是备用路径。只要 A、B 和 C 中至少有一个可用，DSM 就会以轮循机制方式从中选择一个路径。如果所有三个路径都发生故障，则 DSM 就使用备用路径 D。如果路径 A、B 或 C 变为可用，DSM 将停止使用路径 D 并切换回使用 A、B 和 C 之中的可用路  </p><p>  (4)最少队列深度</p><p>  最少队列深度策略通过成比例地将更多的 I/O 请求分配到负载较轻的处理路径来补偿非均匀负载。。例如，考虑有一个 I/O，该 I/O 发送到路径 1 上的 LUN 1，其他 I/O 发送到路径 1 上的 LUN 2。则路径 1 上累积未完成的 I/O 为 2，在路径 2 上它为 0。因此，任一 LUN 的下一个 I/O 将在路径 2 上处理。 </p><p>  (5)加权路径（weighted path）     </p></font><p><font color="read">  加权路径策略允许用户指定每个路径的相对处理负载。数字较大说明此路径的优先级很低。沿着当前处理的数据块数最少的路径发送 I/O 的负载平衡策略。例如，如果有两个 I/O：一个是 10 个字节，而另一个是 20 个字节。这两个都在路径 1 上进行处理，并且都已完成路径 2。则路径 1 上累积的未完成 I/O 数量为 30 个字节。在路径 2 上为 0。因此下一个 I/O 将在路径 2 上处理。</font></p><h4 id="4-挂载并初始化iSCSI硬盘"><a href="#4-挂载并初始化iSCSI硬盘" class="headerlink" title="4. 挂载并初始化iSCSI硬盘"></a>4. 挂载并初始化iSCSI硬盘</h4><p>  操作步骤如下：  </p><p>  ① 在服务器管理器 &gt;&gt; 文件和存储服务 &gt;&gt; 卷 &gt;&gt; 磁盘路径中，选中iSCSI磁盘，右键，点击“联机”；<br>  ②初始化磁盘；<br>  ③分配瓷片空间大小和驱动器；<br>  ④设置文件系统；<br>  ⑤格式化磁盘分区；  </p><p><img src="011.png" alt=""></p><h4 id="5-检查、测试多路径"><a href="#5-检查、测试多路径" class="headerlink" title="5. 检查、测试多路径"></a>5. 检查、测试多路径</h4><p>  <strong>检查多路径</strong></p><p>  配置完对路径和MPIO后，在<code>设备管理器</code>的<code>磁盘驱动器</code>处会发现两个重复磁盘相应地聚合为一个多路径磁盘，在<code>磁盘管理</code>处也显示一块硬盘，跟不启用多路径服务有差异的。</p><p><img src="009.png" alt=""><br><img src="012.png" alt=""><br><img src="013.png" alt=""></p><p>  <strong>测试iSCSI多路径</strong>  </p><p>  测试iSCSI步骤：<br>  ⑴ 通过远程桌面连接，远程到iSCSI服务器和iSCSI客户机；<br>  ⑵ 将Windows Server 2012 R2的系统ISO镜像拷贝到iSCSI磁盘；<br>  ⑶查看iSCSI服务器端、iSCSI客户端性能监视器中各网卡的流量数据；  </p><p>  测试相关数据截图：  </p><p>  <strong>iSCSI客户端</strong></p><p><img src="021.png" alt=""></p><p>  <strong>iSCSI服务器端</strong> </p><p><img src="022.png" alt=""></p><p>  <strong>禁止iSCSI服务器端网卡2：:10.75.75.55,客户机的数据截图</strong>    </p><p><img src="023.png" alt="">  </p><p>  <strong>禁止iSCSI服务器端网卡2：:10.75.75.55,服务器端的数据截图</strong>  </p><p><img src="024.png" alt=""></p><p>  <strong>恢复iSCSI服务器端网卡2，客户端的数据截图</strong>   </p><p><img src="025.png" alt="">  </p><p>  <strong>恢复iSCSI服务器端网卡2，服务器端的数据截图</strong></p><p><img src="026.png" alt=""> </p><p>  <font color="#9932CC">说明：在其中一块网卡出现故障时，iSCSI多路径会自动转移，但转移期间磁盘会处于挂起状态，此时磁盘不会进行读写操作，整个挂起的时间大概几十秒。</font></p><p>  <strong>测试结果总结：</strong>   </p><p>  <strong>数据拷贝过程中，第二、三块网卡的数据流量相对均衡，达到了负载的作用。</strong>   </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Server 2012 R2 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-Windows Server 2012 R2——部署iSCSI共享磁盘</title>
      <link href="/2018/09/13/02-windows-server-2012-r2-bu-shu-iscsi-gong-xiang-ci-pan/"/>
      <url>/2018/09/13/02-windows-server-2012-r2-bu-shu-iscsi-gong-xiang-ci-pan/</url>
      
        <content type="html"><![CDATA[<h3 id="02-Windows-Server-2012-R2——部署iSCSI共享磁盘"><a href="#02-Windows-Server-2012-R2——部署iSCSI共享磁盘" class="headerlink" title="02-Windows Server 2012 R2——部署iSCSI共享磁盘"></a><center>02-Windows Server 2012 R2——部署iSCSI共享磁盘</center></h3><p>  <strong>写在前面：为满足<code>H3C CAS</code>虚拟化挂载共享存储而学习部署iSCSI共享磁盘的搭建，本次以Windows为例，后续会出怎么将Windows的共享磁盘挂载给<code>H3C CAS</code>使用；</strong>    </p><p>  为安装IMC的数据库（SQL Server 2012），而搭建共享磁盘；   </p><p>  <strong>前期准备：</strong>   </p><p>  1）两台Windows Server 2012 R2服务器操作系统两台；<br>  2）网络可达；<br>  3）一台服务器作为iSCSI共享磁盘服务器，提供iSCSI磁盘服务；另外一台用于搭建iMC安装数据库使用；   </p><p>  <strong>相关知识</strong>  </p><p>  iSCSI、SCSI  </p><p>ISCSI（Internet Small Computer System Interface，Internet 小型计算机系统接口)是一种由IBM公司研究开发的IP SAN技术，它是通过 TCP/IP 网络传输 SCSI 指令的协议，让 SCSI 命令通过网络传送到远程 SCSI 设备上，而 SCSI 协议只能访问本地的 SCSI 设备。</p><p>iSCSI 使用客户/服务器模型。客户端称为 initiator，服务器端称为 target。<br>iSCSI 是传输层之上的协议，使用 TCP 连接建立会话。在 initiator 端的 TCP 端口号随机选取， target 的端口号默认是 3260。</p><p>Initiator：通常指用户主机系统，用户产生 SCSI 请求，并将 SCSI 命令和数据封装到 TCP/IP 包中发送到 IP 网络中。  </p><p>Target：通常存在于存储设备上，用于转换 TCP/IP 包中的 SCSI 命令和数据。</p><h4 id="一、提供磁盘服务器操作指南"><a href="#一、提供磁盘服务器操作指南" class="headerlink" title="一、提供磁盘服务器操作指南"></a>一、提供磁盘服务器操作指南</h4><h5 id="1-安装iSCSI服务"><a href="#1-安装iSCSI服务" class="headerlink" title="1. 安装iSCSI服务"></a>1. 安装iSCSI服务</h5><p>  打开服务器管理器 &gt;&gt; 添加角色和功能；  </p><p><img src="001.png" alt="">  </p><p>  点击，选择“基于角色或添加功能安装”，然后点击“下一步”；  </p><p><img src="002.png" alt=""> </p><p>  点击，选择安装角色和功能的服务器或虚拟硬盘中的“从服务器池中选中服务器”，点击“下一步”；  </p><p><img src="003.png" alt=""> </p><p>  在服务器角色的“文件和存储服务”中选择“iSCSI目标存储提供程序”和“iSCSI目标服务器”，点击“下一步”；   </p><p><img src="004.png" alt=""></p><p>  在功能选择界面选择需要安装的功能，如果没有特殊需求，直接点击“下一步”；  </p><p><img src="005.png" alt=""></p><p>  最后，确认安装iSCSI服务所选内容，确认无误，点击“安装”；  </p><p><img src="006.png" alt=""></p><p>  等待安装完成，点后点击“关闭”，进行下一项操作；  </p><p><img src="007.png" alt=""></p><h5 id="2-创建iSCSI虚拟磁盘"><a href="#2-创建iSCSI虚拟磁盘" class="headerlink" title="2.创建iSCSI虚拟磁盘"></a>2.创建iSCSI虚拟磁盘</h5><p>  打开服务器管理器 &gt;&gt;  文件和存储服务  &gt;&gt; iSCSI &gt;&gt; 任务 &gt;&gt; 新建iSCSI虚拟磁盘…  </p><p><img src="008.png" alt=""></p><p>  在新建iSCSI虚拟磁盘向导中，选择服务器（默认为本机），可以选择按卷，也可以选择键入自定义路径（用于存放虚拟磁盘文件）。这里选择按键入自定义路径；选择完后，点击“下一步”。  </p><p><img src="009.png" alt=""></p><p>  填写iSCSI虚拟磁盘名称，路径中可以看到自定义的名称作为了虚拟磁盘文件名,点击“下一步”；  </p><p><img src="010.png" alt=""> </p><p>  选择iSCSI虚拟磁盘的大小和磁盘类型，这里选择固定大小、20GB（按照实际要求分配磁盘大小和磁盘的类型）；</p><p><img src="011.png" alt=""></p><p>  新建iSCSI目标,点击“下一步”；</p><p><img src="012.png" alt=""></p><p>  填写目标名称，点击“下一步”；  </p><p><img src="013.png" alt=""></p><p>  在访问服务器 &gt;&gt; 添加,添加访问iSCSI服务器的客户机（客户端），这里选择“输入选定类型的值”，类型选择“IP地址”，也可以选择其他类型。可以添加多个访问iSCSI服务器的客户端，实现共享存储；  </p><p><img src="014.png" alt=""></p><p>  启用身份验证，也可以选择不启用，这里选择不启用，直接点击“下一步”；  </p><p><img src="015.png" alt="">  </p><p>  确认iSCSI部署配置信息后，点击“创建”，创建虚拟磁盘。  </p><p><img src="016.png" alt="">  </p><p>  等待虚拟磁盘创建成功；  </p><p><img src="017.png" alt=""></p><h5 id="3-后期增加访问服务器的添加操作"><a href="#3-后期增加访问服务器的添加操作" class="headerlink" title="3. 后期增加访问服务器的添加操作"></a>3. 后期增加访问服务器的添加操作</h5><p>  打开服务器管理器 &gt;&gt; 文件和存储服务 &gt;&gt; iSCSI中找到iSCSI目标，选择相应的虚拟磁盘，右键，点击“属性”；  </p><p><img src="018.png" alt=""></p><p>  在新弹出的窗口，选择“发起程序”，点击“添加”，添加新的访问iSCSI服务器的客户机；  </p><p><img src="019.png" alt=""></p><h4 id="二、客户机上配置iSCSI发起程序操作指南"><a href="#二、客户机上配置iSCSI发起程序操作指南" class="headerlink" title="二、客户机上配置iSCSI发起程序操作指南"></a>二、客户机上配置iSCSI发起程序操作指南</h4><h5 id="1-Windows-Server-2012-R2系统连接iSCSI虚拟磁盘"><a href="#1-Windows-Server-2012-R2系统连接iSCSI虚拟磁盘" class="headerlink" title="1. Windows Server 2012 R2系统连接iSCSI虚拟磁盘"></a>1. Windows Server 2012 R2系统连接iSCSI虚拟磁盘</h5><p>  打开服务器管理器，点击“工具”，选择“iSCSI发起程序”，如果会弹出自动启动iSCSI服务的提示信息，点击“是”，等待iSCSI发起程序窗口打开；如果无法弹出该窗口，可以通过将鼠标移至<code>WIN</code>键，右键，点击搜索，搜索“iSCSI发起程序”；  </p><p><img src="020.png" alt=""><br><img src="021.png" alt=""><br><img src="022.png" alt=""></p><p>  在iSCSI发起程序窗口，直接在目标处输入<code>iSCSI服务器的IP地址</code>,d点击快速链接；或者点击“发现”，然后在点击“发现门户”，选择添加目标iSCSI服务器，输入iSCSI服务器的IP地址，点击“确定”；  </p><p><img src="023.png" alt=""></p><p>  在iSCSI发起程序窗口的“卷和设备”选项卡中，点击“自动配置”，将卷列表添加进来；  </p><p><img src="024.png" alt="">  </p><p>  打开服务器管理器 &gt;&gt;  文件和存储服务 &gt;&gt; 卷 &gt;&gt; 磁盘中可以看到多了一块iSCSI总线类型的磁盘，右键该磁盘，选择联机；联机后就可以像本地磁盘一样管理这个iSCSI虚拟磁盘了；</p><p><img src="025.png" alt=""> </p><p>  如果需要正常使用这个磁盘，在服务器管理器 &gt;&gt; 工具 &gt;&gt;  计算机管理，点击磁盘管理，初始化这个20GB的硬盘；然后在新建简单卷；  </p><p><img src="026.png" alt=""></p><h5 id="2-Windws-7-8-10系统连接iSCSI虚拟磁盘"><a href="#2-Windws-7-8-10系统连接iSCSI虚拟磁盘" class="headerlink" title="2. Windws 7/8/10系统连接iSCSI虚拟磁盘"></a>2. Windws 7/8/10系统连接iSCSI虚拟磁盘</h5><p>  打开控制面板,选择查看方式为<code>小图标</code>，找到<code>管理工具</code>;  </p><p><img src="027.png" alt=""></p><p>  双击“iSCSI发起程序”；  </p><p><img src="028.png" alt=""> </p><p>  iSCSI发起程序相关配置，可以参照Windows Server 2012 R2系统连接虚拟磁盘的配置步骤来实现，此处省略iSCSI发起程序的配置步骤。  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Server 2012 R2 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-Windows Server 2012 R2——双网卡绑定</title>
      <link href="/2018/09/12/01-windows-server-2012-r2-shuang-wang-qia-bang-ding/"/>
      <url>/2018/09/12/01-windows-server-2012-r2-shuang-wang-qia-bang-ding/</url>
      
        <content type="html"><![CDATA[<h2 id="01-Windows-Server-2012-R2——双网卡绑定"><a href="#01-Windows-Server-2012-R2——双网卡绑定" class="headerlink" title="01-Windows Server 2012 R2——双网卡绑定"></a><center>01-Windows Server 2012 R2——双网卡绑定</center></h2><h4 id="1-为什么需要双网卡绑定"><a href="#1-为什么需要双网卡绑定" class="headerlink" title="1.为什么需要双网卡绑定"></a>1.为什么需要双网卡绑定</h4><p>  在很多时候，我们在客户现场进行服务器上架安装以及安装操作系统时，都会要求设备接两条或两条以上的链路，确保链路的可靠性，而服务器的IP地址只有一个，那么这样服务器和交换机就会形成二层的环路问题，IP地址也只能配置在一个网口上。那么这种问题就可以通过网卡绑定来处理，这里介绍Windows Server 2012 R2网卡绑定的配置教程，Linux请使用网站搜索功能进行搜索。这里就不介绍Linux的操作。  </p><p>  网卡绑定带来的好处：提高了链路的可靠和冗余、链路备份、数据负载分担。  </p><h4 id="2-双网卡绑定前提条件"><a href="#2-双网卡绑定前提条件" class="headerlink" title="2.双网卡绑定前提条件"></a>2.双网卡绑定前提条件</h4><p>  ⑴ 单网卡多网口；这种方式存在网卡故障；多网卡（可实现网卡冗余）；<br>  ⑵ Windows Server 2012之后版本；<br>  ⑶ 两条网线，交换机端配置链路聚合；<br>  ⑷ 网卡型号（尽量相同）、端口速率（千兆、万兆）。    </p><h4 id="3-双网卡绑定配置操作"><a href="#3-双网卡绑定配置操作" class="headerlink" title="3.双网卡绑定配置操作"></a>3.双网卡绑定配置操作</h4><p>  ⑴ 检查网卡驱动安装；（这里采用H3C CAS安装的Windows Server 2012 R2虚拟机，两块网卡，物理网卡按照实际网卡型号安装网卡驱动。）    </p><p><img src="001.png" alt=""></p><p>  ⑵ 检查当前操作系统；（Windows Server 2012 之前的系统，如果需要实现双网卡绑定，需要借助网卡厂商的软件）  </p><p>  <strong>博通网卡</strong>  </p><pre><code>https://support.hpe.com/hpsc/swd/public/detail?swItemId=MTX_6af1082accaf4f9ca78ad4d19e   </code></pre><p>  <strong>Intel网卡</strong>（请参照下面文档）  </p><p>  <a href="https://pan.baidu.com/s/1ag8865nOu2sbdsQsGC78Kg" target="_blank" rel="noopener">安装、设置与删除 Intel网卡绑定操作指导.rar   提取码：bvsd</a></p><p>  <strong>HP网卡</strong>  </p><pre><code>https://support.hpe.com/hpsc/swd/public/detail?swItemId=MTX_ad2efc3c6b064af5a752f202c3  </code></pre><p>  <strong>软件下载地址</strong>    </p><pre><code>https://github.com/panakot/Windows-NIC-Software.git</code></pre><p>  ⑶ 检查网卡配置信息  </p><p>  在进行网卡绑定之前，首先先检查两个网口是否有配置信息，有，请清空网口的配置信息，配置自动获取IP地址方式。  </p><p><img src="002.png" alt=""></p><p>  ⑷ 打开服务器管理器，点击本地服务</p><p>  NIC组合显示已禁用，两个网口显示DHCP分配  </p><p><img src="003.png" alt=""></p><p>  ⑸ 点击NIC组合，在弹出窗口点击“任务”，并新建组；自定义组名，并将两个网口都勾上，并且在其他属性中，成员模式选择“交换机独立”。物理机可以选择静态成组和LACP，默认为交换机独立；负载平衡模式选择“地址哈希”。</p><p><img src="004.png" alt=""><br><img src="005.png" alt=""></p><p>  <strong>这里说明一下成组模式和负载平衡模式</strong>   </p><p>  <strong>成组模式</strong>   </p><p>  <strong>静态成组(IEEE 802.3ad draft v1)</strong>：此模式配置交换机和主机之间需要哪种链接组合形式，由于这是一个静态配置的解决方案有任何附加协议，所以就不会因为交换机或主机因为电缆的插入错误或其它错误而导致组合的形成。此种模式中，网卡可以工作于不同的速度，就是说可以用不通速度的网卡建立组合, 但同样要求交换机完全支持IEEE 802.3ad 标准，一般情况下，服务器级别的交换机通常支持此模式。   </p><p>  <strong>交换机独立</strong>：这是配置时的默认值，此模式不要求交换机参与组合配置，由于独立模式下的交换机不知道网卡是主机上组合一部分，网卡可以连接到不同的交换机。   </p><p>  <strong>LACA动态组合(IEEE 802.1ax, LACP)</strong>：LACA动态组合是到同一台交换机的链路聚合，只不过不是静态配置的，而是动态构成(也就是自动协商)的。它是通过一种智能的链路协商协议LACP (Link Aggregation Control Protocol)来实现的。LACP原本用于交换机和交换机之间的链路聚合，启用了LACP协议的2台交换机会相互发送LACP的协商报文，当发现2者之间有多条可用的链路的时候，自动将这些链路组合成一条带宽更大的逻辑链路，从而利用负载均衡来实现加宽交换机间链路带宽的目的。  </p><p>  <strong>负载平衡模式</strong>   </p><p>  <strong>地址哈希（Address Hash）</strong>：启用该方式后，数据包到达Teaming后，会根据目的地址信息（MAC地址，IP地址和端口号）执行哈希算法，通过算法的结果，NIC Team决定由哪块物理网卡发送数据包。这种方式无法控制流量的走向，如果有大量数据是流向一个目标地址，那么只会通过一块物理网卡来发送。   </p><p>  <strong>Hyper-V端口</strong>：正如名字显示的，用于Hyper-V的模式，与无法控制的地址哈希相比，这种方式效率更高，数据会通过绑定虚拟网卡的不同物理网卡传输，同时这种绑定是基于每个虚拟网卡，而不是每台虚拟机的。如果是使用Hyper-V外部虚拟交换机建议选择这种方式。  </p><p>  <strong>动态</strong>：这种方式是在Windows Server 2012 R2中新引入的方式，也是最优化的方式，数据会被平分到所有的成员网卡上，最大效率的利用带宽。</p><p><img src="006.png" alt=""></p><p>  <font size="3" color="red">注：可能会提示错误信息，不予理会，耐心等待一会，系统就会显示两块网卡的状态都为活动状态。</font>    </p><p><img src="007.png" alt=""></p><p>  ⑹ 在“更改网络适配器”的窗口中，可以看到新增了一张虚拟网卡“Bound”。  </p><p><img src="008.png" alt=""></p><p>  ⑺ 点击“Bound”网卡，右键“属性”，正常配置网卡信息即可。  </p><p><img src="009.png" alt="">  </p><p>  ⑻ 配置好网卡的IP地址信息后，测试网关和外网。  </p><p><img src="010.png" alt=""> </p><p>  到这里Windows Server 2012 R2双网卡绑定就完成了，物理服务器请按照实际要求配置，此环境为H3C CAS的虚拟化环境，仅供对照参考使用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Server 2012 R2 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
